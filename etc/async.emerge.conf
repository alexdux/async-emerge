#!/bin/bash

# async.emerge.conf - configuration for 'async emerge' toolset
# GPL-2
# version: 2.0
# alexdu@forums.gentoo.org

# Please, don't touch indented (moved to right) section \
# like the next one (this is built-in code, not config;) : 
# --- code ---
	# Skip redefines
	[ -n "$AE_CONFIGURED" ] && return 0

	# Gentoo style console messages
	. /etc/init.d/functions.sh

	# Get script name and path
	PPATH=`dirname $0`
	PNAME=`basename $0`
	
	# Async Emerge staff
	. $PPATH/ae_functions
# --- code ---


# 0. DEFAULT ROOT FOR VCS
AE_ROOT_DEFAULT='/var/async.emerge/'


# --- code ---
	# Set AE_ROOT to AE_ROOT_DEFAULT if AE_ROOT not specified at ENV
	[ "$AE_ROOT" ] || AE_ROOT="$AE_ROOT_DEFAULT"
	#AE_ROOT=${AE_ROOT:=${AE_ROOT_DEFAULT}}
	# Normalize AE root path
	[[ "${AE_ROOT:${#AE_ROOT}-1:1}" != "/" ]] && AE_ROOT="$AE_ROOT/"
	# Get $CCACHE_DIR from maek.conf
	eval `grep CCACHE_DIR /etc/make.conf` # sharing ccache data support. ECONF: -ccache-
# --- code ---
#echo $AE_ROOT


# 1. paths for scripts 
declare -A AE_DIR
AE_DIR[ROOT]="$AE_ROOT"
AE_DIR[GATEWAY]=${AE_DIR[ROOT]}'.gateway/' # trailing / is required
# Please run `portageq pkgdir` to setup the next var!
AE_DIR[PKGDIR]='/usr/portage/packages'
AE_DIR[TRANSPARENT]="${AE_DIR[PKGDIR]} ${AE_DIR[GATEWAY]} /var/tmp /usr/portage/distfiles" # `portageq distdir`
# todo: USE='ccache'
AE_DIR[TRANSPARENT]+=" $CCACHE_DIR" # sharing ccache data support. ECONF: -ccache-
AE_DIR[REBUILD_VAR]="${AE_DIR[GATEWAY]}" # dir for various semi-temp rebuild files
AE_DIR[CHROOT]=${AE_DIR[ROOT]}'chroot' # no trailing '/'
AE_DIR[BIND]=${AE_DIR[ROOT]}'bind' # no trailing '/'
AE_DIR[DELTA]=${AE_DIR[ROOT]}'delta' # no trailing '/'
AE_DIR[ROOT_EXCLUDE]='/tmp /media' # '/proc /sys /var' are added by script
AE_DIR[VAR_EXCLUDE]='' # '${AE_DIR[ROOT]}' is unconditionally added by script


# 2. EXTERNAL COMMANDS configuration
declare -A AE_CMD # to-do: AE_PM='pkgcore'; AE_CMD[AE_PM*]
AE_TMPFSPC=60 # in % of total RAM
# --- code ---
	if [ "$AE_NOTMPFS" ]; then # set to disable 'temerge'
		AE_MEMSIZE=''
	else
		_memTotal=$(cat /proc/meminfo | grep 'MemTotal:')
		_memTotal=${_memTotal/*  }
		let "AE_MEMSIZE=((${_memTotal/ *}*${AE_TMPFSPC}/100))"
	fi
# --- code ---
AE_CMD[ETC_UPDATE]="etc-update"
AE_CMD[PM]='emerge'
[ "$AE_MEMSIZE" ] && AE_CMD[PM]="MEMSIZE=${AE_MEMSIZE}K t${AE_CMD[PM]}"
AE_CMD[TEST]="${AE_CMD[PM]} -pv"
AE_CMD[PM_SEARCH]=' \+\(emerge\|emerging\) \+\-' # ...line to search in logs for emerge_solver
AE_CMD[REVDEP]='revdep-rebuild'
AE_CMD[ECLEAN_DIST]='eclean-dist'
AE_CMD[ECLEAN_PKG]='eclean-pkg -d'


# to-do: merge VCS&COOK, GRS&INSTALL sections ?
# 3. GRS configuration
declare -A AE_GRS


# 4. VCS configuration
declare -A AE_VCS 
# logic
# to-do: add DO_
AE_VCS[VAR_RUN_EXLUDE]='y' # y/n to exclude (wipe out) chrooted /var/run: don't touch!
AE_VCS[CHROOT_MOUNT_PROCFS]='y' # y/n to bind /proc: don't touch!
AE_VCS[CHROOT_MOUNT_SYSFS]='n' # y/n to bind /sys: unclear if it is needed
AE_VCS[CHROOT_START_DBUS]='n' # y/n to start chrooted D-BUS: don't touch!
AE_VCS[UNMOUNT_KILL_BLOCKERS]='y' # don't touch! don't touch!
# ETA<=_TO*(_MT+2)
AE_VCS[UNMOUNT_KILL_BLOCKERS_TO]=1 # Timeout to wait to shutdown process, in seconds
AE_VCS[UNMOUNT_KILL_BLOCKERS_MT]=15 # Max tries before give up


# 5. COOKING logic configuration
declare -A AE_COOK


# 6. INSTALLING logic configuration
declare -A AE_INSTALL
AE_INSTALL[DO_VCS_CLEANUP]='y' # y/n to run ae_delta_cleanup && ae_chroot_cleanup
AE_INSTALL[DO_ECLEAN_DIST]='y' # y/n to run $AE_CMD[ECLEAN_DIST]
AE_INSTALL[DO_ECLEAN_PKG]='y' # y/n to run $AE_CMD[ECLEAN_PKG]
AE_INSTALL[DO_ETC_UPDATE]='y' # y/n to run $AE_CMD[ETC_UPDATE]
# to-do:
#AE_INSTALL[DO_OUTNEWS]='y' # y/n to out news to terminal
#AE_INSTALL[DO_DAEMONS_RESTART]='y' # y/n to run $AE_CMD[DAEMONS_RESTART]


# 7. REBUILDING logic configuration
declare -A AE_REBUILD
AE_REBUILD[REVDEPCO_MT]=5 # Max tries to run revdep-rebuild & co OR 0 to disable
AE_REBUILD[EMERGE_SOLVER_MT]=7 # max heuristic tries to solve emerge fault (python-update,perl-cleaner only)
AE_REBUILD[ALLOW_SKIP_WORLD_UPDATE]='y' # y/n, allow to skip world update if world rebuild is required 
AE_REBUILD[DO_EMERGE_WORLD]='y' # always 'y', 'n' - for debug only
AE_REBUILD[DO_SUBSET_UPDATES]='y' # y/n
AE_REBUILD[DO_DEPCLEAN]='y' # y/n
AE_REBUILD[DO_OBSOLETED_LIBS]='y' # y/n
AE_REBUILD[DO_REVDEP_REBUILD]='y' # y/n
AE_REBUILD[DO_USER_TASKS]='y' # y/n
# file resolution logic: AE_DIR[REBUILD_VAR] + AE_RCMD[(COOK|INSTALL)_FILE_PREFIX] + AE_REBUILD[FILE_*] -> ...
AE_REBUILD[FILE_OBSOLETED_LIBS]='obsoleted-libs.to-revdep' # list of '--libraries' advised to rebuild customers
AE_REBUILD[FILE_SUBSET_SAVED]='crit-pkg.saved-verions' # list of saved versions of subset keys
# move to signs AE_REBUILD[FILE_SUBSET_UPDATES]='subset.updates' # list of changed subset keys


# 8. REBUILDING command configuration
declare -A AE_RCMD
# cooking
AE_RCMD[COOK_TEST]="-DNu @world" # ''/'-DNu @world' - check for update update/
							# '-e @system'/'-e @world'/"-e @system\n-e @world" - check for rebuild
							# in general, any PM check allowed
AE_RCMD[COOK_TEST_SYSTEM_ALT]="-DNu @world" # Alternative if @system fail, recommended: "-DNu @world"
#AE_RCMD[COOK_TEST_OLDER_DAYS]='31' # when system became older, in days
#AE_RCMD[COOK_TEST_OLDER]="-DNu @world\n-e @system\n-e @world" # test cmd(s) for older system
AE_RCMD[COOK_EMERGE]="${AE_CMD[PM]} -ukbDNv --accept-properties=-interactiv world"
AE_RCMD[COOK_SUBSET_UPDATE]="${AE_CMD[PM]} -1 --usepkg n -b -v" # keys for PM
AE_RCMD[COOK_DEPCLEAN]="EMERGE_DEFAULT_OPTS='${EMERGE_DEFAULT_OPTS} --quiet-unmerge-warn' \
	${AE_CMD[PM]} -c --exclude sys-kernel/*"
AE_RCMD[COOK_OBSOLETED_LIBS]="${AE_CMD[REVDEP]} -L ? -- --usepkg n -b -v"
AE_RCMD[COOK_REVDEP_REBUILD]="${AE_CMD[REVDEP]} -- --usepkg n -b -v" 
		# ^ prepend -C for no color, by single-opt only!
AE_RCMD[COOK_USER_TASKS]="${AE_CMD[PM]} --usepkg n -b -v"
AE_RCMD[COOK_FILE_PREFIX]='cook.'

# installing, refer above for help
AE_RCMD[INSTALL_TEST]=''
AE_RCMD[INSTALL_TEST_SYSTEM_ALT]="-DNu @world"
AE_RCMD[INSTALL_EMERGE]="${AE_CMD[PM]} -uDkNv world"
AE_RCMD[INSTALL_SUBSET_UPDATE]="${AE_CMD[PM]} -1 --usepkg y -b -v"
AE_RCMD[INSTALL_DEPCLEAN]="${AE_CMD[PM]} -a -c --exclude sys-kernel/*"
AE_RCMD[INSTALL_OBSOLETED_LIBS]="${AE_CMD[REVDEP]} -L ? -- --usepkg y -b -v"
AE_RCMD[INSTALL_REVDEP_REBUILD]="${AE_CMD[REVDEP]} -- --usepkg y -b -v"
AE_RCMD[INSTALL_USER_TASKS]="${AE_CMD[PM]} --usepkg y -b -v"
AE_RCMD[INSTALL_FILE_PREFIX]='install.'


# 9. DETECTING & REBUILDING SUBSET UPDATES configuration
# (probably this is temporary solution till a further portage releases)
declare -A AE_SUPD
# limit size
AE_SUPD[MAX_ENTRIES]=99
# --- code ---
	# (emulating 2D array by adding numbered prefix)
	# add_subset_update: detector sensor title method command
	# detectors: 
	#	ei 		-> 'emerge --info' 
	#		emerge --info|egrep '[^/]*/[^:]*: '
	#	eixc 	-> 'eix -c' (to-do? alt: ep => 'emerge -p')
	#		(eix '-I*' --only-names dev-lang/python | tr -d '\n' ; echo -e ':'; \
	# 		eix '-I*' --format '<installedversions:NAMEVERSION>' dev-lang/python ) | tr '\n' ' '; echo
	#	pre-eixc	-> like 'eix -c' but checks _before_ world update
	# title: lc for logs
	# methods: 
	#	task			-> add commands to task file (runs at the end)
	#						use shell/${AECMD[USER_TASKS]}
	#	1-pass|2-pass	-> run commands before "depclean" & "(advised) revdep-rebilds". 2-pass temp disable "depclean"
	#						use shell/'call_cmd1_with_emerge_solver' caller
	# command:
	#	if you call a cmd that calls emerge/PM,
	#		add '--with-bdeps y --usepkg n -b --binpkg-respect-use -v --keep-going --color y -j1' to params!
	#	python-updater, perl-cleaner & others
	add_subset_update() {
		# find first available index
		for (( i=0; i<=${AE_SUPD[MAX_ENTRIES]}; i++ )); do 
			[ -z ${AE_SUPD[${i}_DETECTOR]} ] && break
		done
		# exit if $i > 99
		(($i>${AE_SUPD[MAX_ENTRIES]})) && return 1
		# assign values
		AE_SUPD[${i}_DETECTOR]="$1"
		AE_SUPD[${i}_SENSOR]="$2"
		AE_SUPD[${i}_TITLE]="$3" 
		AE_SUPD[${i}_LOG]="${3,,}-update" 
		AE_SUPD[${i}_SIGN]="${3,,}-updated"
		AE_SUPD[${i}_METHOD]="$4"
		AE_SUPD[${i}_CMD]="$5"
		#echo -e "cmd: $5"
		#AE_SUPD[${i}_POSTDC_CMD]="$6"
		# set common vars
		AE_SUPD[TOTAL]=$(($i+1))
		[[ ${AE_SUPD[DETECTORS]} != *-$1-* ]] && AE_SUPD[DETECTORS]+="-$1- "
		return 0
	}
# --- code ---

# add entries in order of process!
# n.b. double quotes does in-place substitution.

# GCC subset... 
# well, it will rebuild all the system...
# if you don`t need it - remove @system & @world
# to-do: USE su_gcc_system ????
add_subset_update 'pre-eixc' 'sys-devel/gcc' 'GCC' '1-pass' \
	"sys-devel/gcc \
\n#gcc-config \$(gcc-config -l | cut -f2 -d '[' | cut -f1 -d ']' | tail -n1) && source /etc/profile \
\n#eix -qI sys-devel/libtool && eval \${AECMD[SUBSET_UPDATE]} sys-devel/libtool \
\n#eix -qI dev-lang/ghc && eval \${AECMD[SUBSET_UPDATE]} dev-lang/ghc \
\n-e @system \
\n#${AE_CMD[PM]} -c sys-devel/gcc \
\n-e @world"
#â„–2\n#fix_libtool_files.sh \$(gcc -dumpversion) \
#gcc-config -l | grep -m1 '*' | sed -e 's:.*\[\(.*\)\].*:\1:'
# to-do: add glibc subset -- ???
# EIX no binary update - critical to AE subset changes logic...
add_subset_update 'pre-eixc' 'app-portage/eix' 'EIX' '1-pass' '--usepkg n app-portage/eix' # --usepkg required
# PYTHON subset...
add_subset_update 'ei' 'dev-lang/python' 'Python' '1-pass' \
	"#eselect python update --\$(eselect python list | sed -e 's:.*\(python.\)\..*\*.*:\1:p;d') \
\n#python-updater -- --usepkg n -b -v"
	# ??? emerge -1pv $(qfile -C -x 'dev-lang/python' /usr/lib/p{ye}* | cut -f1 -d' ')
# PERL subset...
# to-do: add blocker? 'dev-lang/python'
add_subset_update 'eixc' 'dev-lang/perl' 'Perl' '1-pass' \
	'#perl-cleaner --reallyall -- --usepkg n -b -v'
# X.ORG dependencies...
add_subset_update 'eixc' 'x11-base/xorg-server' 'X server' '1-pass' \
	'$(qlist -I -C x11-drivers/)' #
# GTK+ dependencies...
# grep -R "emerge -va1" /usr/portage/
add_subset_update 'eixc' 'x11-libs/gtk+ x11-libs/gdk-pixbuf' 'GTK+' '1-pass' \
	'$(qfile -qC /usr/lib/gtk-2.0/2.*/loaders)' #
# CUPS dependencies...
add_subset_update 'eixc' 'net-print/cups' 'CUPS' '1-pass' \
	"#_packages=\$(qfile -qC /usr/lib/cups /etc/cups | sed -e 's:net-print/cups$::;/^$/d') \
\[ "$_packages" \] && eval FEATURES+=-collision-protect \${AECMD[SUBSET_UPDATE]} \$_packages" #
#\[ "$_packages" \] && FEATURES=-collision-protect ${AE_CMD[PM]} --usepkg n -b -v1 \$_packages" #
#	'$(qfile -qC /usr/lib/cups /etc/cups | sed -e "s:net-print/cups$::")'
# SIP dependencies...
# * When updating dev-python/sip, you usually need to rebuild packages, which depend on dev-python/sip,
# * such as dev-python/PyQt4 and dev-python/qscintilla-python. If you have app-portage/gentoolkit
# * installed, you can find these packages with `equery d dev-python/sip dev-python/PyQt4`.
add_subset_update 'eixc' 'dev-python/sip' 'SIP' '1-pass' \
	'$(equery -q d dev-python/sip dev-python/PyQt4 | sed "/^$/d;s:\(.*\):=\1:")' #
# anything more?..


# 10. LOGS configuration
declare -A AE_LOG
# logs options
AE_LOG[OPT_COLOR]='y' # 'n' not implemented (yet), to-do: auto-detect pipe
# dirs
AE_LOG[DIR_SAVE]='/var/log/async.emerge/' # trailing / is required
AE_LOG[DIR_LAST]='last.'
AE_LOG[DIR_COOK]='cook.'
AE_LOG[DIR_INSTALL]='install.'
# --- code ---
	# update transparent dirs list (for mount/unmount)
	# and normalize paths
	AE_DIR[TRANSPARENT]="${AE_DIR[TRANSPARENT]} ${AE_LOG[DIR_SAVE]}"
	if [ -d ${AE_LOG[DIR_LAST]} ]; then 
		AE_DIR[TRANSPARENT]="${AE_DIR[TRANSPARENT]} ${AE_LOG[DIR_LAST]}"
	else
		AE_LOG[DIR_LAST]="${AE_LOG[DIR_SAVE]}${AE_LOG[DIR_LAST]}"
	fi
# --- code ---
# extensions
AE_LOG[EXT_COOK]='.log'
AE_LOG[EXT_INSTALL]='.log'
# single logs files
# filename resolution logic: DIR_(SAVE|LAST) + FILE_* -> ...
AE_LOG[FILE_CRON]='cron.log'
# multiple logs files
# filename resolution logic: DIR_(SAVE|LAST) + DIR_(COOK|INSTALL) + FILE_* + EXT_(COOK|INSTALL) -> AELOG[*]
#AE_LOG[FILE_SYNC]='sync'
AE_LOG[FILE_CHECK]='world-update.test'
AE_LOG[FILE_CHECK_WARN]='world-update.test.warn'
AE_LOG[FILE_EMERGE]='world-update'
AE_LOG[FILE_EMERGE_WARN]='world-update.warn'
AE_LOG[FILE_SUBSET_UPDATE]='crit-pkgs-versions'
AE_LOG[FILE_DEPCLEAN]='world-depclean'
AE_LOG[FILE_OBSLLIBS]='obsoleted-libs-revdep'
AE_LOG[FILE_REVDEP]='world-revdep'
AE_LOG[FILE_TASKS]='tasks-run'


# 11. SIGNS configuration
declare -A AE_SIGN
# single logs files
AE_SIGN[RBLOOP_LOGIC]="loopLogic" # The big loop stage, sign inside
AE_SIGN[VCSAM]="${AE_DIR[GATEWAY]}.chroot.autoMountedVCS" # sign of auto-mounted (by _ae_root_mount) AUFS, PID inside
# multiple logs files
# filename resolution logic: ${AE_DIR[GATEWAY]} + AE_RCMD[(COOK|INSTALL)_FILE_PREFIX] + *_UPDATE -> ...
# move to rebuild AE_SIGN[SUBSET_SAVED]='subset-saved'
AE_SIGN[SUBSET_UPDATES]='crit-pkgs.to-update' # List of detected subset updates
# per-user sign files
AE_SIGN[STATE]="$HOME/.ae_state" # ae_state once-a-day mark
AE_SIGN[BASHRC]="$HOME/.bashrc" # ae_state once-a-day mark


# 12. LOCKS configuration
# scripts lock
declare -A AE_PID
AE_PID[AE_REBUILD_PATH]="${AE_DIR[GATEWAY]}"
AE_PID[AE_REBUILD_FILE]="ae_makeworld.pid"
# users lock
declare -A AE_LOCK
AE_LOCK[AE_STATE_LOCK]="$HOME/.ae_state.lock" # ae_state .lock


# 13. AE_STATE configuration
declare -A AE_STATE
AE_STATE[USE_EIX]='y' # y/n, y=eix, n=emerge
AE_STATE[PERIOD]=43200 # in seconds, 86400 = 24h, 43200 = 12h, 21600 = 6h ...


# 14. TASKS configuration
declare -A AE_TASK
# filename resolution logic: ${AE_DIR[GATEWAY]} + AE_RCMD[(COOK|INSTALL)_FILE_PREFIX] + FILE_LIST -> ...
AE_TASK[FILE_LIST]='tasks.txt'


# 99. The End
AE_CONFIGURED=1

