#!/bin/bash

# ae_rebuild - 'async emerge' Gentoo system re-builder
# GPL ver. 2
# version: 1.2
# 2011, Alex Dubenetsky: alexdu@forums.gentoo.org

# Features:
#	- Work in both GRS and VCS environments
#	- Stop/rerun supported
#	- Update world using $AE_BUILD_EMERGE_CMD
#	- Revdep-rebuild world using $AE_BUILD_REVDEP_CMD
# removed	- Prerun update and revdep for logging
#	- Allow only one instance of $0 for one VCS via $AE_BUILD_LOCK
#	- Run subset updates (gcc update, python update, perl update), configurable
#	- PM solver for subset updates
# removed	- Run python-updater, perl-cleaner if advised by "install warns"
#	- Revdep obsoleted libs advised by "install warns" then remove it
#	- Run --depclean
#	- Cycling revdepping-updating-cleaning (max ${AE_REBUILD[REVDEPCO_MT]} times)
#	- Run tasks: user given command/merging
# To-do:

# get config
. /etc/async.emerge.conf

# check if AUFS is mounted, to-do: check if ae_chroot is running in the VCS
#if [[ "`mount | grep $AE_ROOT | grep aufs`" == "" ]]; then
#	eerror "  AUFS is not mounted! $PNAME is not operational!!!"
#	exit 1
#fi

# Detect VCS, set $AE_VCS
AE_VCS=${#AE_CHROOT_PS1}

# set config key prefix
(($AE_VCS)) && eType='COOK' || eType='INSTALL'

# Adjust CMD
declare -A AECMD
for i in ${!AE_RCMD[*]}; do
	[[ "$i" != $eType'_'* ]] && continue
	AECMD[${i:${#eType}+1}]=${AE_RCMD[$i]}
done

# Adjust LOGS
declare -A AELOG
for i in ${!AE_LOG[*]}; do
	[[ "$i" != 'FILE_'* ]] && continue
	AELOG[${i:5}]=${AE_LOG[DIR_SAVE]}${AE_LOG[DIR_$eType]}${AE_LOG[$i]}${AE_LOG[EXT_$eType]}
	AELOG[${i:5}_LAST]=${AE_LOG[DIR_LAST]}${AE_LOG[DIR_$eType]}${AE_LOG[$i]}${AE_LOG[EXT_$eType]}
done

# Adjust SIGNS
declare -A AESIGN
for i in ${!AE_SIGN[*]}; do
	[[ "$i" != *'_UPDATE'* ]] && continue
	AESIGN[$i]=${AE_DIR[GATEWAY]}.${AECMD[FILE_PREFIX]}${AE_SIGN[$i]}
done


# check locking with ${AE_PID[AE_REBUILD]}
do_lock "${AE_PID[AE_REBUILD_PATH]}${AECMD[FILE_PREFIX]}${AE_PID[AE_REBUILD_FILE]}" 1 \
	"  $PNAME is already running, but only one instance is allowed for one VCS! Exit."

# emerge caller: info_msg emerge_cmd log_file_last warn_file_last log_file warn_file -> $cmdRet
# exit if retcode > 1
call_emerge() {
	local log_last=$3 warn_last=$4 log=$5 warn=$6
	# fixit
	[[ $1 ]] && einfo "  $1 ..."
	# pre-logging emerging
	dt_mark | tee "$log_last" > "$warn_last" 2>&1
	if [[ "$2" == *'1>&3'* ]]; then 
		#echo '=== *1>&3* ==='
		eval "$2"
	else
		eval "$2 >> $log_last 2>> $warn_last"
	fi
	cmdRet=$? # 102 = killed (Ctrl+C)
	eend $cmdRet
	# if an error occurred - add log to warn (some errors do not out to stderr)
	### (($cmdRet)) && cat "$log_last" >> "$warn_last" 2>&1
	# care logs
	cat "$log_last" >> "$log" 2>&1
	cat "$warn_last" >> "$warn" 2>&1
	echo >> "$log" 2>&1
	echo >> "$warn" 2>&1
	# exit on an error
	echo "Retcode $cmdRet" >> "$log_last" 2>&1
	(($cmdRet>1)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 3; }
	return $cmdRet
}

# a command caller: info_msg cmd log_file_last log_file -> return, $cmdRet
# exit if retcode > 1
call_cmd1() {
	local log_last=$3 log=$4
	[ "$1" ] && einfo "    $1 ..."
	dt_mark > "$log_last" 2>&1
	eval "$2" >> "$log_last" 2>&1
	cmdRet=$?
	eend $cmdRet
	cat "$log_last" >> "$log" 2>&1
	echo >> "$log" 2>&1
	# exit on an error
	echo "Retcode $cmdRet" >> "$log_last" 2>&1
	(($cmdRet>1)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 4; }
	return $cmdRet
}

# same as call_cmd1, but exit if recode > 0
call_cmd0() {
	call_cmd1 "$1" "$2" "$3" "$4"
	# exit on an error
	(($cmdRet)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 4; }
	return $cmdRet
}

# emerge solver: msg log_file_last -> $cmdRet
# Features:
#	- for 'python-updater' and 'perl-cleaner' ONLY !!!
# To-do:
#	- this is awful --> emerge --ignore-invalid-atoms
# parse log, get emerge cmd, try to build it 'anyway' by escaping invalid atoms
# : info_msg log_file
emerge_solver() {
	local log_last=$2 # log=$3
	[ "$1" ] && ewarn "    Emerge fault, trying to solve:"
	
	# get emerge cmd
	# to-do: change to internal var?
	eCmd=$((grep " \+${AE_CMD[PM_SEARCH]} \+-" "$log_last" | grep -m1 -v -e '--sync' -e '--info' | \
				cut -f2- -d'-') 2>> "$log_last")

	if [ "$eCmd" ]; then
		# loop
		loop=${AE_REBUILD[EMERGE_SOLVER_MT]} # to-do: add const
		cmdRet=1
		while (($loop)) && (($cmdRet)); do # emerge reports us only one error at once
			einfo "      trying to solve emerge '$1', try "$((${AE_REBUILD[EMERGE_SOLVER_MT]}-$loop+1)) \
				"of ${AE_REBUILD[EMERGE_SOLVER_MT]} ..."
		
			# check masked
			#aMasked=$((grep 'masked by:.*keyword' "$log_last" | tail -n1) 2>> "$log_last")
			aMasked=$((grep -m1 'masked by:.*keyword' "$log_last") 2>> "$log_last")
			if [[ $aMasked ]]; then
				# get packet category/name
				aMasked=${aMasked%%-[0-9]*}; aMasked=${aMasked/* /}
				# too slow: shopt -s extglob; eCmd=${eCmd/$aMasked*([! ])/}; shopt -u extglob
				s=$eCmd; eCmd=''
				for i in $s; do [[ $i != *$aMasked* ]] && eCmd=$eCmd' '$i; done
				eCmd=${eCmd:1}
			fi
	
			# check 'there are no ebuilds'
			#aMissed=$((grep 'there are no ebuilds to satisfy' "$log_last" | tail -n1 | cut -f2 -d'"') 2>> "$log_last")
			aMissed=$((grep -m1 'there are no ebuilds to satisfy' "$log_last" | cut -f2 -d'"') 2>> "$log_last")
			#echo "$aMissed"
			if [[ $aMissed ]]; then
				# get packet category/name
				aMissed=${aMissed%%-[0-9]*}; aMasked=${aMissed/* /}
				# too slow: shopt -s extglob; eCmd=${eCmd/$aMissed*([! ])/}; shopt -u extglob
				s=$eCmd; eCmd=''
				for i in $s; do [[ $i != *$aMissed* ]] && eCmd=$eCmd' '$i; done
				eCmd=${eCmd:1}
			fi
		
			# check 'pulled in by'
			# (x11-libs/gdk-pixbuf-2.22.1-r2::gentoo, ebuild scheduled for merge) pulled in by
			for aBlocker in $(grep -m1 'pulled in by' "$log_last" | sed 's/.*(\(.*\)::.*/\1/'); do
				#echo "$aBlocker"
				if [[ $aBlocker ]]; then
					# get packet category/name
					aBlocker=${aBlocker%%-[0-9]*}; aMasked=${aBlocker/* /}
					# too slow: shopt -s extglob; eCmd=${eCmd/$aMissed*([! ])/}; shopt -u extglob
					s=$eCmd; eCmd=''
					for i in $s; do [[ $i != *$aBlocker* ]] && eCmd=$eCmd' '$i; done
					eCmd=${eCmd:1}
				fi
			done


			# run PM
			eval "${AE_CMD[PM]} -$eCmd" >> "$log_last" 2>&1
			cmdRet=$?
			eend $cmdRet
			echo "Retcode $cmdRet" >> "$log_last" 2>&1
			if (($cmdRet>102)); then return 102; fi
		
			((loop--))
		done
	else
		ewarn "      Nothing to solve. Check if '--keep-going' logic works."; eend 0
	fi
}

# Features:
#	- for 'python-updater' and 'perl-cleaner' ONLY !!!
#	- trying hard to escape invalid atoms (--skip-invalid-atoms)
# a command caller: info_msg cmd log_file_last log_file -> return, $cmdRet
# if something goes wrong - it calls emerge_solver
# exit if retcode > 1
call_cmd1_with_emerge_solver() {
	local log_last=$3 log=$4
	[ "$1" ] && einfo "    $1 ..."
	dt_mark > "$log_last" 2>&1
	# eval
	#$($2 >> "$log_last" 2>&1)
	eval "$2" >> "$log_last" 2>&1
	cmdRet=$?
	eend $cmdRet
	(($cmdRet>1)) && return $cmdRet
	(($cmdRet)) && emerge_solver "$1" "$3" # "$4"
	cat "$log_last" >> "$log" 2>&1
	echo >> "$log" 2>&1
	# exit on an error
	echo "Retcode $cmdRet" >> "$log_last" 2>&1
	(($cmdRet>1)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 4; }
	#einfo "    Solved. $1 (continue)"
	return $cmdRet
}


# scan $1 for 'revdep-rebuild --library' then add libs to ${AE_REBUILD[FILE_OBSOLETED_LIBS]: log_file_to_scan
scan_for_rdlibs() {
	# * Please run revdep-rebuild --library libnss3.so.12 ,
	local f=${AE_DIR[REBUILD_VAR]}.${AECMD[FILE_PREFIX]}${AE_REBUILD[FILE_OBSOLETED_LIBS]}
	# in order of appearance
	for i in $(grep -E 'revdep-rebuild +\-\-library' "$1" | sed "s/.*library[ =]*\([^ ,]*\).*/\1/;s/['\"]//g" ); {
		# avoid duplicates - it's safe
		[ `grep "^$i$" "$f" 2>/dev/null` ] || echo "$i" >> "$f"
	}
	# sorted: no...
	#grep -E 'revdep-rebuild +\-\-library' "$1" | cut -f2 -d"'" | sort -u >> "$f"
	# return true if file exists (there is libs to rebuilt in it)
	[ -e "$f" ]
	return $?
}

# scan and return to $sysvers versions of major system stuff
scan_for_sysvers() {
	sysvers=''
	
	# get versions with 'emerge --info' detector if required
	if [[ ${AE_SUPD[DETECTORS]} == *-ei-* ]]; then
		sysvers=`emerge --info|egrep '[^/]*/[^:]*: '`
	fi
	
	# get more versions with other detectors
	for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do
		# switch detector
		case "-${AE_SUPD[${s}_DETECTOR]}-" in
			-ei-) ;;
			-eixc-) for sens in ${AE_SUPD[${s}_SENSOR]}; do
						ver=`eix '-I*' -e --only-names $sens | tr -d '\n'`
						if [ "$ver" ]; then
							sysvers=`echo "$sysvers"; echo -n "$ver" ; \
								echo -en ':\t'; eix '-I*' -e --format '<installedversions:VERSION>' $sens |\
								 tr -d '\n'; echo`
						else
							sysvers=`echo "$sysvers"; echo -e "$sens:\t-- not installed --"`
							AE_SUPD[${s}_NOTINSTALLED]=1
						fi
					done
					;;
			*) echo "Invalid version detectors method: '${AE_SUPD[${s}_DETECTOR]}'!"
		esac
	done
	
	return 0
}

# compare and save to $2 $sysvers with saved in $1
# compare_sysvers: $saved_sysvers_file
compare_sysvers() {
	#rm "$2" 2>1 >/dev/null
	# check versions
	for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do
		for sens in ${AE_SUPD[${s}_SENSOR]}; do # multisensor
			# not installed
			[ "${AE_SUPD[${s}_NOTINSTALLED]}" ] && continue
			# old version
			ov=`grep "$sens:" "$1"`
			ov=`echo ${ov/*:}`
			uv=''
			# check if update is going
			if [ -e "$2" ]; then
				uv=`grep "$sens:" "$2"`
				if [ "$uv" ]; then 
					uv=`echo ${uv/*:}`; uv=`echo ${uv/->*}`
					[ "$uv" ] && ov=$uv || uv='!'
				fi
			fi
			# new version
			nv=`echo "$sysvers" | grep "$sens:"`
			nv=`echo ${nv/*:}`
			# cmp
			if [[ "$ov" != "$nv" ]] ; then
				# save vers internally
				#AE_SUPD[${s}_OLDVER]=$ov
				#AE_SUPD[${s}_NEWVER]=$nv
				if [ "${AE_SUPD[${s}_UPDATED]}" ]; then
					AE_SUPD[${s}_UPDATED]="${AE_SUPD[${s}_UPDATED]}; $sens: $ov -> $nv"
				else
					AE_SUPD[${s}_UPDATED]="$sens: $ov -> $nv"
				fi
				# remove old subset item
				if [ "$uv" ]; then # update
					s1=`grep -v "$sens:" "$2"`
					if [ "$s1" ]; then
						echo "$s1" > "$2"
					else
						rm -v "$2" 2>&1 >/dev/null
					fi
				fi
				# (re)add item
				echo "$sens: $ov -> $nv" >> "$2" 
			fi
		done
	done
}


# start logs subsets updates
dt_mark > "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
# save sysvers
subsetf=${AE_DIR[REBUILD_VAR]}.${AECMD[FILE_PREFIX]}${AE_REBUILD[FILE_SUBSET_SAVED]}
if [ -e "$subsetf" ]; then
	einfo "  Critical system packages versions already saved - use it ..."
	echo " * Existed data (world rebuild was interrupted previously):" >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
	eend 0
else
	einfo "  Saving critical system packages versions ..."
	scan_for_sysvers
	echo "$sysvers" > "$subsetf"
	echo " * Critical packages versions:" >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
	eend 0
fi
cat "$subsetf" >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
echo >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1


# *** REBUILD & CO MAIN LOOP ***
max_loop=${AE_REBUILD[REVDEPCO_MT]}
max_loop2=((2*${AE_REBUILD[REVDEPCO_MT]}))
# Control for loop iterations:
loopLogic=0xFF
# 0x01 - rebuild world is needed
# 0x02 - subset update is needed
# 0x04 - deplcean is needed
# 0x08 - rebuild obsoleted libs is needed
# 0x10 - revdep-rebuild is needed
# 0x20 - user task is needed
for (( loop=1; $loop <= $max_loop && $loopLogic; loop++ )); do

	einfo "  Updating system with restoring of consistency, try $loop of $max_loop:"
	
	# REBUILD world with emerge
	if [ "${AE_REBUILD[DO_EMERGE_WORLD]}" == "y" ]; then
		if (($loopLogic & 0x01)); then
			if (($AE_VCS)); then
				call_emerge "  Rebuilding world" "${AECMD[EMERGE]}" \
					"${AELOG[EMERGE_LAST]}" "${AELOG[EMERGE_WARN_LAST]}" "${AELOG[EMERGE]}" "${AELOG[EMERGE_WARN]}"
				if !(($cmdRet)); then touch "${AE_SIGN[COOKED]}" 2>&1; fi
			else
				# ((/path/to/oraMon.pl 2>&1 1>&3 | tee /tmp/errors.log) 3>&1 1>&2 | tee /tmp/output.log) > /tmp/final.log 2>&1
				call_emerge "  Rebuilding world" \
					"((${AECMD[EMERGE]} 2>&1 1>&3 | tee \$warn_last) 3>&1 1>&2 | tee \$log_last) 2>&1" \
					"${AELOG[EMERGE_LAST]}" "${AELOG[EMERGE_WARN_LAST]}" "${AELOG[EMERGE]}" "${AELOG[EMERGE_WARN]}"
			fi
		
			(($cmdRet)) || ((loopLogic&=0xFE))
		
			# libs advised to rebuild consumers
			# ... double is not good, but just to be sure (duplicates will skipped)
			einfo "    Collecting libs advised for consumers rebuild ..."
			scan_for_rdlibs "${AELOG[EMERGE_LAST]}"
			(($?)) || ((loopLogic|=0x08))
			scan_for_rdlibs "${AELOG[EMERGE_WARN_LAST]}"
			(($?)) || ((loopLogic|=0x08))
			eend 0
		else
			einfo "    World rebuilding was already done."; eend 0
		fi
	else
		ewarn "    World rebuilding is not configured."; eend 1
	fi


	# Subset updates
	if [ "${AE_REBUILD[DO_SUBSET_UPDATES]}" == "y" ]; then
		if (($loopLogic & 0x02)); then
			# stop next try of subset updates (if fail any update - set flag again...)
			((loopLogic&=0xFD))
			# check sysvers
			einfo "    Checking critical system packages versions ..."
			scan_for_sysvers
			compare_sysvers "$subsetf" "${AESIGN[SUBSET_UPDATES]}"
			rm -v "$subsetf" 2>&1 >/dev/null
			if [ -e "${AESIGN[SUBSET_UPDATES]}" ]; then
				echo " * New critical packages versions:" >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
				cat "${AESIGN[SUBSET_UPDATES]}" >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
			else
				echo " * No new critical packages versions found." >> "${AELOG[SUBSET_UPDATE_LAST]}" 2>&1
			fi
			cat "${AELOG[SUBSET_UPDATE_LAST]}" >> "${AELOG[SUBSET_UPDATE]}" 2>&1
			echo >> "${AELOG[SUBSET_UPDATE]}" 2>&1
			eend 0

			einfo "    Check for various subsets updates:"
			undetected=''		
			notinstalled=''
			for (( i=0; i<${AE_SUPD[TOTAL]}; i++ )); do
				if [ "${AE_SUPD[${i}_UPDATED]}" ]; then
					cmdRet=0
					einfo "      ${AE_SUPD[${i}_TITLE]} update detected, update method is '${AE_SUPD[${i}_METHOD]}':"
					einfo "        (${AE_SUPD[${i}_UPDATED]})"
					updated=0
					log=${AE_LOG[DIR_SAVE]}${AE_LOG[DIR_$eType]}${AE_SUPD[${i}_LOG]}${AE_LOG[EXT_$eType]}
					log_last=${AE_LOG[DIR_LAST]}${AE_LOG[DIR_$eType]}${AE_SUPD[${i}_LOG]}${AE_LOG[EXT_$eType]}
					# start last log
					dt_mark > "$log_last" 2>&1
					# choose update method and do update
					case "-${AE_SUPD[${i}_METHOD]}-" in
						-task-) # adding cmds to task file
								if (($AE_VCS)); then
									# array cmds
									#declare -a Cmds
									mapfile -t Cmds < <(echo -e "${AE_SUPD[${i}_CMD]}")
									einfo "        Adding ${#Cmds[*]} tasks to update the subset:"
									for ((k=0; k < ${#Cmds[*]}; k++)); do
										einfo "          - '${Cmds[$k]}'"
									done
									ae_add_task "${AE_SUPD[${i}_CMD]}" 2>>"$log_last" >&2 && \
										true && updated=2
									eend 0
									#unset Cmds
								else
									echo "Using tasks from VCS." >> "$log_last"
									einfo "        Using tasks from VCS."
									eend 0
								fi
								;;
						-1-pass-|-2-pass-) 
								# 2-pass logic:
								if [ "${AE_SUPD[${i}_METHOD]}" == "2-pass" ]; then
									# get opponent for 'two-pass' update
									if [ "$eType" == "COOK" ]; then
										osf="${AE_DIR[GATEWAY]}.${AE_RCMD[INSTALL_FILE_PREFIX]}${AE_SIGN[SUBSET_UPDATES]}"
									else
										osf="${AE_DIR[GATEWAY]}.${AE_RCMD[COOK_FILE_PREFIX]}${AE_SIGN[SUBSET_UPDATES]}"
									fi
									if [ -e "$osf" ]; then
										gexp=''
										for sens in ${AE_SUPD[${i}_SENSOR]}; do gexp+=" -e $sens:"; done # multisensor
										ostest=$((`grep $gexp "$osf" | grep '2-pass' | wc -l`))
									else
										ostest=0
									fi
									if !(($ostest)); then
										ewarn "        This is the first pass of the update. " \
											"Skipping package switch and system depclean."; eend 0
										dcPend=1
										updated=1
									fi
								fi
								# update (1-pass/second pass) logic
								if !(($updated)); then
									# array cmds
									#declare -a Cmds
									mapfile -t Cmds < <(echo -e "${AE_SUPD[${i}_CMD]}")
									# play cmds
									for ((k=0; k < ${#Cmds[*]}; k++)); do
										(($cmdRet)) && break
										cmd="${Cmds[$k]# ?}"
										if [ "$cmd" ]; then
											# choose caller
											if [[ "$cmd" == \#* ]]; then # shell cmd
												cmd=${cmd:1}
												# --usepkg logic
												!(($AE_VCS)) && cmd=${cmd/--usepkg n/--usepkg y}
												#einfo "        Running shell command:"
												einfo "        - '$cmd' ..."
												eval "$cmd >> \"$log_last\" 2>&1"
												echo "Retcode $cmdRet" >> "$log_last" 2>&1
												cmdRet=$?
											else # PM
												if [[ "$cmd" == \$* || "$cmd" == \`* ]]; then
													cmd=$(eval echo -n $cmd)
												fi
												if [ "$cmd" ]; then
													#einfo "        Running PM:"
													call_cmd1_with_emerge_solver \
														"    - ${AECMD[SUBSET_UPDATE]} '$cmd'" \
														"${AECMD[SUBSET_UPDATE]} $cmd" \
														"$log_last" "$log"
													cmdRet=$?
												else
													einfo "        Not found any dependencies for this subset."
													cmdRet=0
												fi
											fi
											# get result
											if (($cmdRet)); then 
												eend 1;	updated=0
											else 
												eend 0; updated=2
											fi
										else
											echo "skip empty line in '${AE_SUPD[${i}_CMD]}'"
										fi
									done
									#unset Cmds
								fi
								;;
						*) echo "Invalid update method: '${AE_SUPD[${s}_METHOD]}'!"
					esac
				
					# copy last to logs
					cat "$log_last" >> "$log" 2>&1
					echo >> "$log" 2>&1

					# subset sign update
					if (($updated)); then
						# multisensor
						for sens in ${AE_SUPD[${i}_SENSOR]}; do 
							# save update sign (for 2-pass)
							sul=`grep "$sens:" "${AESIGN[SUBSET_UPDATES]}"`
							sul=${sul/*: /}; sul=${sul/2-pass, /}
							# remove subset sign
							nsupd=`grep -v "$sens:" "${AESIGN[SUBSET_UPDATES]}"`
							# remove empty
							if [ "$nsupd" ]; then
								echo "$nsupd" > "${AESIGN[SUBSET_UPDATES]}"
							else
								rm -v "${AESIGN[SUBSET_UPDATES]}" 2>&1 >/dev/null
							fi
							if !(($updated-1)); then # readd subset sign with '1-pass'
								echo "$sens: 2-pass, $sul" >> "${AESIGN[SUBSET_UPDATES]}"
							fi
						done
						# if update is done - remove sign of update
						if (($updated-1)); then
							unset AE_SUPD[${i}_UPDATED]
						fi
						# collect hints for libs comsumers rebuild
						#scan_for_rdlibs "$log"
						scan_for_rdlibs "$log_last"
						(($?)) || ((loopLogic|=0x08))
					else # pend depclean if collision occurred
						dcPend=1
						# failed - set the bit again!!!
						((loopLogic|=0x02))
					fi
				elif [ "${AE_SUPD[${i}_NOTINSTALLED]}" ]; then
					[ "$notinstalled" ] && notinstalled+=', '
					notinstalled+=${AE_SUPD[${i}_TITLE]}
				else
					[ "$undetected" ] && undetected+=', '
					undetected+=${AE_SUPD[${i}_TITLE]}
				fi
			done
			[ "$undetected" ] && einfo "      $undetected updates were not detected."; eend 0
			[ "$notinstalled" ] && einfo "      $notinstalled updates were skipped: not installed."; eend 0
		else
			einfo "    Subsets updates was already done."; eend 0
		fi
	else 
		ewarn "    Checking for various subsets updates is not configured."; eend 0
	fi

	
	# Cleanup all unneded (depclean), emerge -ca
	if [ "${AE_REBUILD[DO_DEPCLEAN]}" == "y" ]; then
		if (($loopLogic & 0x04)); then
			if [ $dcPend ]; then
				ewarn "    Cleaning system is pending till the next cooking. "\
					"(2-pass subset update behavior or subset update fail)"; eend 0
			else
				if [[ "${AECMD[DEPCLEAN]}" == *a* ]]; then # interactively (GRS)
					#call_cmd1 "Cleaning system from unused dependencies" "${AECMD[DEPCLEAN]}" \
					#			"&1" "/dev/null"
					einfo "    Cleaning system from unused dependencies (interactively):"
					# idiot. dt_mark > "${AELOG[DEPCLEAN_LAST]}" 2>&1
					# to-do: add tee to log
					eval "${AECMD[DEPCLEAN]}" # >> "${AELOG[DEPCLEAN_LAST]}" 2>&1
					cmdRet=$?
					eend $?
					# cat "${AELOG[DEPCLEAN_LAST]}" >> "${AELOG[DEPCLEAN]}" 2>&1
					# echo >> "${AELOG[DEPCLEAN]}" 2>&1
				else # bash mode (GRS/VCS)
					call_cmd1 "Cleaning system from unused dependencies" "${AECMD[DEPCLEAN]}" \
								"${AELOG[DEPCLEAN_LAST]}" "${AELOG[DEPCLEAN]}"
				fi
				(($cmdRet)) || ((loopLogic&=0xFB))
			fi
		else
			einfo "    Cleaning system was already done."; eend 0
		fi
	else 
		ewarn "    Cleaning system is not configured."; eend 0
	fi

	
	# Revdep customers for advised libs, revdep --libs
	if [ "${AE_REBUILD[DO_OBSOLETED_LIBS]}" == "y" ]; then
		if (($loopLogic & 0x08)); then
			# sign file
			f=${AE_DIR[REBUILD_VAR]}.${AECMD[FILE_PREFIX]}${AE_REBUILD[FILE_OBSOLETED_LIBS]}
			if [ -e "$f" ]; then
				cmd=${AECMD[OBSOLETED_LIBS]/\?/\\\(`cat "$f" | sed -e :a -e '$!N; s/\n/\\\|/; ta'`\\\)}
				#echo "obslibs cmd: $cmd"
				# call revdep
				call_cmd1 "Rebuilding consumers for "`cat "$f" | wc -l`" advised libs" "$cmd" \
						"${AELOG[OBSLLIBS_LAST]}" "${AELOG[OBSLLIBS]}"
				# check the result
				if !(($cmdRet)); then # OK
					einfo "      Removing advised libs if has no owner ..."
					# go throgh the list and unlink lost libs
					for i in `cat "$f"`; do 
						[ `equery b "$i" | head -n1` ] || { 
							rm -v "$i" 2>&1 | tee -a "${AELOG[OBSLLIBS_LAST]}" >> "${AELOG[OBSLLIBS]}"
						}
					done
					eend 0
					true && rm -v "$f" 2>&1 >/dev/null
					((loopLogic&=0xF7))
				else # FAIL
					ewarn "    Save lost libs list for further rebuild."; eend 0
				fi
			else
				einfo "    Not found any libs advised for consumers rebuild."; eend 0
			fi
		else
			einfo "    Rebuilding consumers for advised libs was already done. "; eend 0
		fi
	else 
		ewarn "    Rebuilding consumers for advised libs is not configured."; eend 0
	fi

	
	# Revdep system-wide
	if [ "${AE_REBUILD[DO_REVDEP_REBUILD]}" == "y" ]; then
		if (($loopLogic & 0x10)); then
			# call global revdep
			call_cmd0 "Rebuilding world with revdep-rebuild" "${AECMD[REVDEP_REBUILD]}" \
					"${AELOG[REVDEP_LAST]}" "${AELOG[REVDEP]}"
			(($cmdRet)) || ((loopLogic&=0xEF))
			# collect hints for libs comsumers rebuild
			scan_for_rdlibs "${AELOG[REVDEP_LAST]}"
			# to-do: move the next to func
			if !(($?)); then
				einfo "      Found libs advised for consumers rebuild:"
				if (($max_loop < $max_loop2)); then
					einfo "      Adding extra pass to the system-care loop."; eend 0
					((max_loop++))
				else
					ewarn "      Skip adding extra pass to the system-care loop: the maximum is reached."; eend 0
				fi
				((loopLogic|=0x08))
			fi
		else
			einfop "    Rebuilding world with revdep-rebuild was already done."; eend 0
		fi
	else 
		ewarn "    Rebuilding world with revdep-rebuild is not configured."; eend 0
	fi


	# Proceed tasks with cmd/emerge
	if [ "${AE_REBUILD[DO_USER_TASKS]}" == "y" ]; then
		if (($loopLogic & 0x20)); then
			f="${AE_DIR[GATEWAY]}${AECMD[FILE_PREFIX]}${AE_TASK[FILE_LIST]}"
			if [ -e "$f" ]; then 
				einfo "    Running scheduled tasks:" # + loop+1
				# walk through to-do
				cmdRet=0
				while [[ -e "$f"  && !(($cmdRet)) ]]; do
					i=$(head -n1 "$f")
					i=${i# ?} # strip leading spaces
					if [ "$i" ]; then
						# start last log
						dt_mark > "${AELOG[TASKS_LAST]}" 2>&1
						# choose caller
						is="$i"
						if [[ "$i" == \#* ]]; then # shell cmd
							i=${i:1}
							# --usepkg logic
							!(($AE_VCS)) && i=${i/--usepkg n/--usepkg y}
							#einfo "      Running shell command: '$i' ..."
							einfo "      - '$i' ..."
							eval "$i >> \"${AELOG[TASKS_LAST]}\" 2>&1"
							echo "Retcode $?" >> "${AELOG[TASKS_LAST]}" 2>&1
						else # PM
							# to-do: check for zero param (as at subset updates)
							#einfo "      Running PM: '${AECMD[USER_TASKS]} $i' ..."
							einfo "      - ${AECMD[USER_TASKS]} '$i' ..."
							eval "${AECMD[USER_TASKS]} $i >> \"${AELOG[TASKS_LAST]}\" 2>&1"
							echo "Retcode $?" >> "${AELOG[TASKS_LAST]}" 2>&1
						fi
						cmdRet=$?
						eend $?
						# copy last to logs
						cat "${AELOG[TASKS_LAST]}" >> "${AELOG[TASKS]}" 2>&1
						echo >> "${AELOG[TASKS]}" 2>&1
						# add cmd to install to-do
						if (($AE_VCS)); then
							echo "$is" >> "${AE_DIR[GATEWAY]}${AE_RCMD[INSTALL_FILE_PREFIX]}${AE_TASK[FILE_LIST]}"
						fi
					else
						echo "skip empty line in '$f'"
					fi
					# remove 1st line from to-do
					c=$(tail -n+2 "$f")
					if [ "$c" ]; then
						echo -e "$c" > "$f"
					else
						rm -f "$f"
					fi
				done

				(($cmdRet)) || ((loopLogic&=0xDF))

				# add depclean and revdep-rebuild pass
				if (($max_loop < $max_loop2)); then
					einfo "      Adding extra pass to the system-care loop."; eend 0
					((max_loop++))
				else
					ewarn "      Skip adding extra pass to the system-care loop: the maximum is reached."; eend 0
				fi
				((loopLogic|=0x14))

				# check for rebuild advised libs
				scan_for_rdlibs "${AELOG[TASKS_LAST]}"
				(($?)) || ((loopLogic|=0x08))
			else
				einfo "    There are no scheduled tasks."; eend 0
			fi
		else
			einfo "    Scheduled tasks was already done."; eend 0
		fi
	else 
		ewarn "    Scheduled tasks is not configured."; eend 0
	fi
done

# Bye World
if (($loopLogic)); then
	eerror "  Can't recover system consistency! Will try again next time."; eend 1
else
	einfo "  Now system is consistently."; eend 0
fi

#times

#return $cmdRet
exit $loopLogic


