#!/bin/bash

# ae_makeworld - 'async emerge' Gentoo system updater/rebuilder
# GPL ver. 2
# version: 2.0
# 2011, Alex Dubenetsky: alexdu@forums.gentoo.org

# Features:
#	- Work in both GRS and VCS environments. Auto-detect it.
#	- Stop/rerun supported
#	- Widely configurable
#	- Care about system in the cycle (max ${AE_REBUILD[REVDEPCO_MT]} times):
#		- check for critical system packages updates at several phases
#			- rebuild the whole world if detected
#		- update world
#		- update subsets (python update, perl update & others)
#		- run depclean
#		- rebuild consumers for advised obsoleted libs
#		- run revdep-rebuild
#		- do scheduled user tasks (shell commands or emerge params)
#	- Allow only one instance of $0 for one GRS and one for VCS
#	- PM solver for subset updates
#	- For VCS care about actual state report
#	- For GRS additionally does:
#		- Clean-up VCS if not building
#		- Unlink obsoleted distfiles
#		- Unlink obsoleted binary packages
#		- Updating configs (interactively)
# To-do:
#	- add services reload for GRS

# get config
. /etc/async.emerge.conf

# check if AUFS is mounted
#if [[ "`mount | grep $AE_ROOT | grep aufs`" == "" ]]; then
#	eerror "  AUFS is not mounted! $PNAME is not operational!!!"
#	exit 1
#fi
# to-do: check if ae_chroot is running in the VCS ???

# Detect VCS, set $AE_VCS
#AE_VCS=${#AE_CHROOT_PS1}
AE_VCS=${#AE_STATE_SKIP}

# Get param (1)
# -v	verbose (copy out to stdout), default for GRS
# -q	quite (don't cope out to stdout) default for VCS
if (($AE_VCS)); then
    [[ "$1" == '-v' ]] && AE_MW_VERBOSE='verbose'
else
    [[ "$1" != '-q' ]] && AE_MW_VERBOSE='verbose'
fi
[ "$AE_MW_VERBOSE" ] && einfo "($PNAME: verbose mode is ON)"

[ "$AE_TMPFS[SIZE]" ] || \
	ewarn "($PNAME: skip to use 'temerge': not enough memory or disabled in the config.)"

# set config key prefix
(($AE_VCS)) && eType='COOK' || eType='INSTALL' # COOK = VCS, INSTALL = GRS
(($AE_VCS)) && cPName='ae_chroot ' || cPName=''

# Adjust CMD
declare -A AECMD
for i in ${!AE_RCMD[*]}; do
	[[ "$i" != $eType'_'* ]] && continue
	AECMD[${i:${#eType}+1}]=${AE_RCMD[$i]}
done

# Adjust LOGS
declare -A AELOG
for i in ${!AE_LOG[*]}; do
	[[ "$i" != 'FILE_'* ]] && continue
	AELOG[${i:5}]=${AE_LOG[DIR_SAVE]}${AE_LOG[DIR_$eType]}${AE_LOG[$i]}${AE_LOG[EXT_$eType]}
	AELOG[${i:5}_LAST]=${AE_LOG[DIR_LAST]}${AE_LOG[DIR_$eType]}${AE_LOG[$i]}${AE_LOG[EXT_$eType]}
done

# Adjust SIGNS
declare -A AESIGN
for i in ${!AE_SIGN[*]}; do
	[[ "$i" != *'_'* ]] && continue
	AESIGN[$i]=${AE_DIR[GATEWAY]}.${AECMD[FILE_PREFIX]}${AE_SIGN[$i]}
done


# check locking with ${AE_PID[AE_REBUILD_FILE]}
do_lock "${AE_PID[AE_REBUILD_PATH]}${AECMD[FILE_PREFIX]}${AE_PID[AE_REBUILD_FILE]}" 1 \
	"  $PNAME is already running, but only one instance is allowed for one VCS! Exit."


# emerge caller: info_msg emerge_cmd log_file_last warn_file_last log_file warn_file -> $cmdRet
# exit if retcode > 1
call_emerge() {
	local log_last=$3 warn_last=$4 log=$5 warn=$6
	# fixit
	[[ $1 ]] && einfo "  $1 ..."
	# pre-logging emerging
	dt_mark | tee "$log_last" &> "$warn_last"
	# "((${AECMD[EMERGE]} 2>&1 1>&3 | tee \$warn_last) 3>&1 1>&2 | tee \$log_last) 2>&1"	
	if [ "$AE_MW_VERBOSE" ]; then
		eval "(($2 2>&1 1>&3 | tee -a \"$warn_last\") 3>&1 1>&2 | tee -a \"$log_last\") 2>&1"
	else
		eval "$2 >> $log_last 2>> \"$warn_last\""
	fi
	cmdRet=$? # 102 = killed (Ctrl+C)
	eend $cmdRet
	# if an error occurred - add log to warn (some errors do not out to stderr)
	### (($cmdRet)) && cat "$log_last" >> "$warn_last" 2>&1
	echo "Retcode: $cmdRet" &>> "$log_last"
	# care logs
	cat "$log_last" &>> "$log"
	cat "$warn_last" &>> "$warn"
	echo &>> "$log"
	echo &>> "$warn"
	# exit on an error
	(($cmdRet>1)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 3; }
	return $cmdRet
}

# a command caller: info_msg cmd log_file_last log_file -> return, $cmdRet
# exit if retcode > 1
call_cmd1() {
	local log_last=$3 log=$4
	[ "$1" ] && einfo "    $1 ..."
	dt_mark &> "$log_last"
	if [ "$AE_MW_VERBOSE" ]; then
		eval "$2 2>&1 | tee -a \"$log_last\""
	else
		eval "$2 &>> \"$log_last\""
	fi
	cmdRet=$?
	eend $cmdRet
	echo "Retcode: $cmdRet" &>> "$log_last"
	cat "$log_last" &>> "$log"
	echo &>> "$log"
	# exit on an error
	(($cmdRet>1)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 4; }
	return $cmdRet
}

# same as call_cmd1, but exit if recode > 0
call_cmd0() {
	call_cmd1 "$1" "$2" "$3" "$4"
	# exit on an error
	(($cmdRet)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 5; }
	return $cmdRet
}

# emerge solver: msg log_file_last -> $cmdRet
# Features:~4.2_p20
#	- for 'python-updater' and 'perl-cleaner' ONLY !!!
# To-do:
#	- this is awful --> emerge --ignore-invalid-atoms
# parse log, get emerge cmd, try to build it 'anyway' by escaping invalid atoms
# : info_msg log_file
emerge_solver() {
	local log_last="$2" # log=$3
	local i s eCmd loop aMasked aMissed aBlocker
	[ "$1" ] && ewarn "    Emerge fault, trying to solve:"
	
	# get emerge cmd
	# to-do: change to internal var?
	eCmd=$((grep "${AE_CMD[PM_SEARCH]}" "$log_last" | grep -m1 -v -e '--sync' -e '--info' | cut -f2- -d'-') \
			2>> "$log_last")

	if [ "$eCmd" ]; then
		# loop
		loop=${AE_REBUILD[EMERGE_SOLVER_MT]} # to-do: add const
		cmdRet=1
		while (($loop)) && (($cmdRet)); do # emerge reports us only one error at once
			einfo "      trying to solve emerge '$1', try "$((${AE_REBUILD[EMERGE_SOLVER_MT]}-$loop+1)) \
				"of ${AE_REBUILD[EMERGE_SOLVER_MT]} ..."

			s=''
		
			# check masked
			aMasked=$((grep -m1 'masked by:.*keyword' "$log_last") 2>> "$log_last")
			if [ "$aMasked" ]; then
				# get packet category/name
				aMasked=${aMasked%%-[0-9]*}; aMasked=${aMasked/* /}
				# too slow: shopt -s extglob; eCmd=${eCmd/$aMasked*([! ])/}; shopt -u extglob
				s=$eCmd; eCmd=''
				for i in $s; do [[ "$i" != *"$aMasked"* ]] && eCmd+=" $i"; done
				eCmd=${eCmd:1}
			fi
	
			# check 'there are no ebuilds'
			# emerge: there are no ebuilds to satisfy "=net-print/hplip-3.10.9-r1"
			aMissed=$((grep -m1 'there are no ebuilds to satisfy' "$log_last" | cut -f2 -d'"') 2>> "$log_last")
			if [ "$aMissed" ]; then
				# get packet category/name
				aMissed=${aMissed%%-[0-9]*}; aMasked=${aMissed/* /}
				s=$eCmd; eCmd=''
				for i in $s; do [[ "$i" != *"$aMissed"* ]] && eCmd+=" $i"; done
				eCmd=${eCmd:1}
			fi
		
			# check 'pulled in by', not tested!
			# (x11-libs/gdk-pixbuf-2.22.1-r2::gentoo, ebuild scheduled for merge) pulled in by
			for aBlocker in $(grep -m1 'pulled in by' "$log_last" | sed 's/.*(\(.*\)::.*/\1/'); do #'
				#echo "$aBlocker"
				if [ "$aBlocker" ]; then
					# get packet category/name
					aBlocker=${aBlocker%%-[0-9]*}; aMasked=${aBlocker/* /}
					s=$eCmd; eCmd=''
					for i in $s; do [[ "$i" != *"$aBlocker"* ]] && eCmd+=" $i"; done
					eCmd=${eCmd:1}
				fi
			done

			[ "$s" ] || {
				ewarn "      (...nothing more could be fixed in request: make one try to rebuild and return.)"
				loop=1
			}
			
			# run PM
#			eval "${AE_CMD[PM]} -$eCmd" &>> "$log_last"
			if [ "$AE_MW_VERBOSE" ]; then 
				eval "${AE_CMD[PM]} -$eCmd 2>&1 | tee -a \"$log_last\""
			else
				eval "${AE_CMD[PM]} -$eCmd &>> \"$log_last\""
			fi
			cmdRet=$?
			eend $cmdRet
			echo "Retcode: $cmdRet" &>> "$log_last"
			if (($cmdRet>102)); then return 102; fi
		
			((loop--))
		done
	else
		ewarn "      Nothing to solve. Check if '--keep-going' logic works."; eend 0
	fi
	return 0
}

# Features:
#	- for 'python-updater' and 'perl-cleaner' ONLY !!!
#	- trying hard to escape invalid atoms (--skip-invalid-atoms)
# a command caller: info_msg cmd log_file_last log_file -> return, $cmdRet
# if something goes wrong - it calls emerge_solver
# exit if retcode > 1
call_cmd1_with_emerge_solver() {
	local log_last=$3 log=$4
	[ "$1" ] && einfo "    $1 ..."
	if [ "$log" ]; then # reset last_log
		dt_mark &> "$log_last"
	else # append last_log
		dt_mark &>> "$log_last"
	fi		
	# eval
	#$($2 >> "$log_last" 2>&1)
	if [ "$AE_MW_VERBOSE" ]; then 
		eval "$2 2>&1 | tee -a \"$log_last\""
	else
		eval "$2 &>> \"$log_last\""
	fi
	cmdRet=$?
	eend $cmdRet
	#(($cmdRet>1)) && return $cmdRet
	(($cmdRet==1)) && emerge_solver "$1" "$3" # "$4"
	echo "Retcode: $cmdRet" &>> "$log_last"
	[ "$log" ] && { # end last_log
		cat "$log_last" &>> "$log"
		echo &>> "$log"
	}
	# exit on an error
	(($cmdRet>1)) && { false && echo "Exit status: $cmdRet"; eend 1; exit 4; }
	#einfo "    Solved. $1 (continue)"
	return $cmdRet
}


# scan $1 for 'revdep-rebuild --library' then add libs to ${AE_REBUILD[FILE_OBSOLETED_LIBS]: log_file_to_scan
# optional $2 - ignore list
scan_for_rdlibs() {
	local ignore=''
	[ "$2" ] && ignore=$2
	# * Please run revdep-rebuild --library libnss3.so.12 ,
	local f="${AE_DIR[REBUILD_VAR]}.${AECMD[FILE_PREFIX]}${AE_REBUILD[FILE_OBSOLETED_LIBS]}"
	local i s

	# in order of appearance
	for i in $(grep -E 'revdep-rebuild +\-\-library' "$1" | sed "s/.*library[ =]*\([^ ,]*\).*/\1/;s/['\"]//g" ); {
		# avoid duplicates - it's safe and check ignore list
		#echo "ignore: -$ignore-"
		[ "$(egrep "^(<<< )?$i$" <(echo -e "$ignore") 2> /dev/null)" ] || {
			[ "$(egrep "^(<<< )?$i$" "$f" 2> /dev/null)" ] || echo "$i" >> "$f"
			# check for unlink advise
			# *   # rm '/usr/lib64/libmpfr.so.1'
			s=$(grep -m1 "rm .*$i" "$1" 2>/dev/null)
			if [ "$s" ]; then
				# normalize libname (add path from 'rm')
				s=$(sed "s:.* rm '\(.*\)':\1:" <<< "$s")
				# mark a lib for unlink with '<<< '
				echo -e "$(sed "s:^$i$:<<< $s:" "$f")" > "$f"
			fi
		}
	}
	# sorted: no...
	#grep -E 'revdep-rebuild +\-\-library' "$1" | cut -f2 -d"'" | sort -u >> "$f"
	# return true if file exists (there is libs to rebuilt in it)
	[ -e "$f" ]
	# set request for obsoleted libs update, the var is described below
	(($?)) || loopLogic_set OBSOLETED_LIBS_REVDEP
	return $?
}

# scan and return to $sysvers versions of major system stuff
# scan_for_sysvers: ---
scan_for_sysvers() { 
	local s sens pkg dtc iver uver eig
	sysvers=''
	
	# get versions with 'emerge --info' detector if required
	for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do 					
		for sens in ${AE_SUPD[${s}_SENSOR]}; do 
			[[ "-${AE_SUPD[${s}_DETECTOR]}-" == "-ei-" ]] && {
				[ "$eig" ] && eig+="\n"
				eig+="^${sens}:"
			}
		done
	done

	# get from emerge --info $eig list of packages
	[ "$eig" ] && sysvers=$(emerge --info | grep -f <(echo -e $eig))"\n"
	
	# get more versions with other detectors
	for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do
		# switch detector
		dtc="-${AE_SUPD[${s}_DETECTOR]}-"
		case $dtc in
			-ei-) ;;
			-eixc-|-pre-eixc-) 
					for sens in ${AE_SUPD[${s}_SENSOR]}; do
						pkg=$(eix '-I*' -e --format '<category>/<name>' $sens)
						if [ "$pkg" ]; then
							sysvers+="$pkg:\t"
							iver=$(eix '-I*' -e --format '<installedversions:VERSION>' $sens)
							sysvers+="$iver"
							if [[ "$dtc" == "-pre-eixc-" ]]; then
								uver=$(eix '-I*' -e --format '<bestversion:VERSION>' $sens)
								#uver=$(eix '-I*' -e --format '<bestslotupgradeversions:VERSION>' $sens)
								#"$uver" || uver=$(eix '-I*' -e --format '<bestversion:VERSION>' $sens)
								[[ "$iver" == "$uver" ]] || {
									sysvers+=" -> $uver"
									# set mark for critical packages update (=> world rebuild)
									loopLogic_set _CRITICAL_UPDATE
									AE_SUPD[${s}_CRITICAL_CHANGE]=1									
									#AE_SUPD[${s}_PENDED]=''
								}
							fi
						else
							sysvers+="$sens:\t-- not installed --"
							AE_SUPD[${s}_NOTINSTALLED]=1
						fi
						sysvers+="\n"
					done
					;;
			*) echo "Invalid version detectors method: '${AE_SUPD[${s}_DETECTOR]}'!"
		esac
	done
	
	return 0
}

# compare and save to $2 $sysvers with saved in $1
# compare_sysvers: $saved_sysvers_file $delta_sysvers_file
# (new version taken from $sysvers var)
compare_sysvers() { # todo: change echo to sed/vars
	local s s1 sens ov uv nv vmrk

	# check versions
	for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do
		for sens in ${AE_SUPD[${s}_SENSOR]}; do # multisensor
			# not installed
			[ "${AE_SUPD[${s}_NOTINSTALLED]}" ] && continue
			# get old version
			ov=$(grep -m1 "$sens:" "$1")
			ov=$(echo ${ov/*:})
			uv=''
			# check if update is going, then update old version
			if [ -e "$2" ]; then
				uv=$(grep -m1 "$sens:" "$2")
				if [ "$uv" ]; then 
					uv=$(echo ${uv/*:}); uv=$(echo ${uv/ ->*})
					#uv=${${uv/*:}/->*}
					[ "$uv" ] && ov=$uv || uv='!'
				fi
			fi
			# get new version
			nv=$(grep -m1 "$sens:" <(echo -e "$sysvers"))
			nv=$(echo ${nv/*:})
			[[ "$nv" == *'->'* ]] && nv=${nv/*-> } # check
			# compare old & new versions
		#echo "1. sens:$sens| ov:$ov| nv:$nv| uv:$uv| upd:${AE_SUPD[${s}_UPDATED]}"			
			if [[ "$ov" != "$nv" || "$ov" == *'->'* ]]; then
				vmrk="$sens: $ov"
				[[ "$ov" != *'->'* ]] && vmrk+=" -> $nv"
				if [ "${AE_SUPD[${s}_UPDATED]}" ]; then
					[[ "${AE_SUPD[${s}_UPDATED]}" != *"$vrmk"* ]] && AE_SUPD[${s}_UPDATED]+="; $vmrk"
				else
					AE_SUPD[${s}_UPDATED]+="$vmrk"
				fi

				# remove old subset item
				if [ "$uv" ]; then # update
					s1=$(grep -v "$sens:" "$2")
					if [ "$s1" ]; then
						echo -e "$s1" > "$2"
					else
						rm -v "$2" &> /dev/null
					fi
				fi
				# (re)add item
				echo "$vmrk" >> "$2" 
			else # reset update sign ???
				unset AE_SUPD[${s}_UPDATED]
			fi
		#echo "2. sens:$sens| ov:$ov| nv:$nv| uv:$uv| upd:${AE_SUPD[${s}_UPDATED]}"			
		done
	done
}



# Msg 'World update (Rebuild)'
einfo "Starting Gentoo Update:"
# Control for loop iterations:
loopLogic_set() { bitflag_set loopLogic ${AE_RBLL[$1]}; }
loopLogic_reset() { bitflag_reset loopLogic ${AE_RBLL[$1]}; }
loopLogicLog () { 
	# to-do: add global var where save prev call of it, then xor and take other bits from file
	#echo $(($(cat "${AESIGN[RBLOOP_LOGIC]}" 2>/dev/null || echo '0')|$loopLogic)) > "${AESIGN[RBLOOP_LOGIC]}"
	echo $loopLogic > "${AESIGN[RBLOOP_LOGIC]}"
}
loopLogic_set _LOOP_START
loopLogicLog


# Check for possibility of update|rebuild world - stop if impossible
if [ "${AECMD[TEST]}" ]; then
	einfo "  Testing for possibilities of various updates:"
	mapfile -t Cmds < <(echo -e "${AECMD[TEST]}")
	for ((k=0; k < ${#Cmds[*]}; k++)); do
		einfo "    - testing with '${Cmds[$k]}' ..."
	
		check_if_emerge_possible "${AE_CMD[TEST]} ${Cmds[$k]}" \
								"${AELOG[CHECK_LAST]}" "${AELOG[CHECK_WARN_LAST]}" \
								"${AELOG[CHECK]}" "${AELOG[CHECK_WARN]}"
		cmdRet=$?
		eend $cmdRet
		(($cmdRet)) && {
			eerror "  Oops, human is needed !!!"
			eerror "  Test '${cPName}${AE_CMD[TEST]} ${Cmds[$k]}' failed."
			#eerror "  Use 'cat ${AELOG[CHECK_WARN_LAST]}' to see why ..."
			eend 2
			echo -e "\n\033[01;37m<<< Log file '${AELOG[CHECK_WARN_LAST]}' >>>\033[00;10m"
			cat "${AELOG[CHECK_WARN_LAST]}"
			echo
			exit 8447
		}
	done
	AEUPDATETEST=${AECMD[TEST]}
else
	ewarn "  Testing for possibilities of various updates is not configured ..."; eend 0
	AEUPDATETEST=''
fi


# *** REBUILD & CO MAIN LOOP ***
#
#
# to-do: better reset 'last' log files
# to-do: revise setting & clearing loop flags! ???
max_loop=${AE_REBUILD[REVDEPCO_MT]}
subsetf="${AE_DIR[REBUILD_VAR]}.${AECMD[FILE_PREFIX]}${AE_REBUILD[FILE_SUBSET_SAVED]}"
#
#
for (( loop=0; $loop < $max_loop && $loopLogic; loop++ )); do

	# reset temp pending
	dcPend=''
	dcPend2=''
	alcruPend=''
	
	einfo "  Updating system with restoring of consistency, pass "$((loop+1))" of $max_loop:"
	loopLogicLog

	# experimental and most likely not needed at all feature	
	if (($loop)); then
		# Reload ENV
		if [ "${AE_REBUILD[DO_RELOAD_ENV]}" == "y" ]; then
			einfo "    Reloading ENV ..."
			. /etc/profile && \
			echo -n '         ' && env-update && \
			hash -r
			eend $?
#		else
#			ewarn "    Reloading ENV is not configured."; eend 0
		fi
#	else
	fi
	
	# to-do: restore after TERM? or incomplete in tasks
	# SAVE CRITICAL PACKAGES VERSIONS (only if world update or subset update is scheduled - todo: is it OK?)
	if (($loopLogic & (${AE_RBLL[WORLD_UPDATE]}|${AE_RBLL[SUBSET_UPDATE]}) )); then
		# start logs subsets updates
		dt_mark &> "${AELOG[SUBSET_UPDATE_LAST]}"
		# save sysvers
		if [ -e "$subsetf" ]; then
			einfo "    Critical system packages versions already saved - use it ..."
			echo " * Existed data (world update was interrupted previously):" &>> "${AELOG[SUBSET_UPDATE_LAST]}"
			eend 0
			# but check for world rebuild is needed...
			if [ "$(grep -m1 -e '->' "$subsetf")" ]; then
				loopLogic_set _CRITICAL_UPDATE
				# get updating critical packages
				mapfile -t Pkgs < <(grep -e '->' "$subsetf")
				for ((k=0; k < ${#Pkgs[*]}; k++)); do
					#echo "Pkgs:${Pkgs[$k]},Pkgs:${Pkgs[$k]/:*/}"
					for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do
						if [[ "${AE_SUPD[${s}_SENSOR]}" == *"${Pkgs[$k]/:*/}"* ]]; then
							AE_SUPD[${s}_CRITICAL_CHANGE]=1
						fi
					done
				done
			fi
		else
			einfo "    Saving critical system packages versions ..."
			scan_for_sysvers # (set 0x1000 in the func, if needed)
			echo -e "$sysvers" > "$subsetf"
			echo " * Critical packages versions:" &>> "${AELOG[SUBSET_UPDATE_LAST]}"
			eend 0
		fi
		cat "$subsetf" &>> "${AELOG[SUBSET_UPDATE_LAST]}"
		#echo &>> "${AELOG[SUBSET_UPDATE_LAST]}"
		cat "${AELOG[SUBSET_UPDATE_LAST]}" &>> "${AELOG[SUBSET_UPDATE]}"
		echo &>> "${AELOG[SUBSET_UPDATE]}"
	fi


	# UPDATE WORLD with emerge
	if [ "${AE_REBUILD[DO_EMERGE_WORLD]}" == "y" ]; then
		if (($loopLogic & (${AE_RBLL[WORLD_UPDATE]}|${AE_RBLL[_CRITICAL_UPDATE]}) )); then
			updateExclude='' # local, for pended critical updates
			# Checking for rebuild
			if (($loopLogic & ${AE_RBLL[_CRITICAL_UPDATE]})) && [ "${AE_REBUILD[ALLOW_SKIP_WORLD_UPDATE]}" == "y" ]; then
				echo -en "\033[01;37m"
				echo "   *   ATTENTION!  Something important like GCC is going to been updated!   *" 
				echo "   *                Skipping World update till the next pass!               *" 
				#echo "   *                   The world rebuild is necessary!                      *"
				#echo "   *                Going to REBUILD WORLD then came back.                  *"
				#echo "   *          WORLD REBUILD will been added to scheduled tasks!             *"
				#echo "   *  Possible WORLD UPDATE is pending till the scheduled tasks will done;) *"
				echo -en "\033[00;10m"
				echo -en "\a"
				#for (( i=0; i < 3; i++ )); do echo -en "\a"; sleep 1; done
				
				# $loop == 1 && 
				if [[ "${AECMD[TEST]}" != *'@system'* || "${AECMD[TEST]}" != *'@world'* ]]; then
					einfo "    Testing for possibility of world rebuild for critical system packages updates:"
					
					# walk through critical changes
					for ((s=0; s<${AE_SUPD[TOTAL]}; s++)); do
						# reset PENDED
						AE_SUPD[${s}_PENDED]=''
						if [ "${AE_SUPD[${s}_CRITICAL_CHANGE]}" ]; then
							# get cmds for world rebuild
							mapfile -t Cmds < <(echo -e "${AE_SUPD[${s}_CMD]}")
							einfo "      - for package '${AE_SUPD[${s}_TITLE]}':"
							for ((k=0; k < ${#Cmds[*]}; k++)); do
								if [[ "${Cmds[$k]}" != '#'* ]]; then
									einfo "        - testing with '${Cmds[$k]}' ..."

									check_if_emerge_possible "${AE_CMD[TEST]} ${Cmds[$k]}" \
															"${AELOG[CHECK_LAST]}" "${AELOG[CHECK_WARN_LAST]}" \
															"${AELOG[CHECK]}" "${AELOG[CHECK_WARN]}"
									cmdRet=$?
									eend $cmdRet
									if (($cmdRet)); then
										if [[ "${Cmds[$k]}" == *'@system'* ]]; then
											ewarn "          Well... '@system' is subset of the '@world'..."
											ewarn "          So we can try to do some heuristic:"\
													"step back to world update,"\
													"then came back to the subset update:"
											if [[ "${AEUPDATETEST}" == "${AECMD[TEST_SYSTEM_ALT]}" ]]; then
												einfo "          - possibility of world update is already tested"
												eend 0
												cmdRet=0
											else
												einfo "          - testing if world update is possible with"\
														"'${AECMD[TEST_SYSTEM_ALT]}' ..."
												check_if_emerge_possible "${AE_CMD[TEST]} ${AECMD[TEST_SYSTEM_ALT]}" \
																	"${AELOG[CHECK_LAST]}" "${AELOG[CHECK_WARN_LAST]}" \
																	"${AELOG[CHECK]}" "${AELOG[CHECK_WARN]}"
												cmdRet=$?
												eend $cmdRet
											fi
										fi
										if (($cmdRet)); then # even update is imposable
											eerror "    Oops, human is needed !!!"
											eerror "    Test '${cPName}${AE_CMD[TEST]} ${Cmds[$k]}' failed."
											#eerror "    Use 'cat ${AELOG[CHECK_WARN_LAST]}' to see why ..."
											eend 2
											echo -e "\n\033[01;37m<<< Log file '${AELOG[CHECK_WARN_LAST]}' >>>\033[00;10m"
											cat "${AELOG[CHECK_WARN_LAST]}"
											echo
											exit 8448
										else # step back to world update
											ewarn "            Ok, world update is possible ..."\
													"Pend '${AE_SUPD[${s}_TITLE]}' subset update till the next pass."
											eend 0
											# clean 'pre-eix'
											AE_SUPD[${s}_PENDED]=1
											# reset critical update flag
											loopLogic_reset _CRITICAL_UPDATE
										fi
									fi
								fi
							done
							# exclude critical updates
							# to-do: add multisensos support
							updateExclude+=" --exclude ${AE_SUPD[${s}_SENSOR]}"
						fi
					done
				else
					ewarn "    Possibility of world rebuild is already tested, skipping it ..."; eend 0
				fi
				# skip depclean: set dcPend2
				dcPend2=1
			fi
			
			# World update logic
			if !(($loopLogic & ${AE_RBLL[_CRITICAL_UPDATE]})) || [ "${AE_REBUILD[ALLOW_SKIP_WORLD_UPDATE]}" != "y" ]; then
				call_emerge "  Updating world" "${AECMD[EMERGE]}${updateExclude}" \
					"${AELOG[EMERGE_LAST]}" "${AELOG[EMERGE_WARN_LAST]}" "${AELOG[EMERGE]}" "${AELOG[EMERGE_WARN]}"
		
				# set subset update, revdep-rebuild
				loopLogic_set SUBSET_UPDATE
				loopLogic_set WORLD_REVDEP
				# set flags
				if !(($cmdRet)); then # if OK
					# reset this
					loopLogic_reset WORLD_UPDATE
					# set depclean
					loopLogic_set WORLD_DEPCLEAN
				else # if NOT OK
					# reset depclean
					loopLogic_reset WORLD_DEPCLEAN
					# restrict adv. rebuild remove
					alcruPend=1
				fi
		
				# libs advised to rebuild consumers
				# ... double is not good, but just to be sure (duplicates will skipped)
			#	einfo "    Collecting libs advised for consumers rebuild ..."
				scan_for_rdlibs "${AELOG[EMERGE_LAST]}"
				scan_for_rdlibs "${AELOG[EMERGE_WARN_LAST]}"
			#	eend 0
			fi
			
			# reset 0x1000 anyway
			loopLogic_reset _CRITICAL_UPDATE
		else
			einfo "    World already has been updated."; eend 0
		fi
	else
		# reset this
		loopLogic_reset WORLD_UPDATE
		ewarn "    World updating is not configured."; eend 1
	fi
	loopLogicLog


	# SUBSET UPDATES
	if [ "${AE_REBUILD[DO_SUBSET_UPDATES]}" == "y" ]; then
		if (($loopLogic & ${AE_RBLL[SUBSET_UPDATE]})); then
			# stop next try of subset updates (if fail any update - set flag again...)
			loopLogic_reset SUBSET_UPDATE
			# check sysvers
			if [ -e "$subsetf" ]; then 
				einfo "    Checking critical system packages versions ..."
				scan_for_sysvers
				compare_sysvers "$subsetf" "${AESIGN[SUBSET_UPDATES]}"
				rm -v "$subsetf" &> /dev/null
				if [ -e "${AESIGN[SUBSET_UPDATES]}" ]; then
					echo " * Critical packages versions updates:" &>> "${AELOG[SUBSET_UPDATE_LAST]}"
					cat "${AESIGN[SUBSET_UPDATES]}" &>> "${AELOG[SUBSET_UPDATE_LAST]}"
				else
					echo " * Critical packages versions updates not found." &>> "${AELOG[SUBSET_UPDATE_LAST]}"
				fi
				cat "${AELOG[SUBSET_UPDATE_LAST]}" &>> "${AELOG[SUBSET_UPDATE]}"
				echo &>> "${AELOG[SUBSET_UPDATE]}"
				eend 0
			else
				eerror "Internal error: saved data about critical packages versions is not found. Stop."; eend 1
				exit 0xFF
			fi

			einfo "    Checking for various subsets updates:"
			# reset local stat
			pended=''					
			undetected=''		
			notinstalled=''
			for (( i=0; i<${AE_SUPD[TOTAL]}; i++ )); do
				if [[ "${AE_SUPD[${i}_UPDATED]}" && ! "${AE_SUPD[${i}_PENDED]}" ]]; then
					cmdRet=0
					einfo "      ${AE_SUPD[${i}_TITLE]} update detected, update method is '${AE_SUPD[${i}_METHOD]}':"
					einfo "        (${AE_SUPD[${i}_UPDATED]})"
					updated=0
					log=${AE_LOG[DIR_SAVE]}${AE_LOG[DIR_$eType]}${AE_SUPD[${i}_LOG]}${AE_LOG[EXT_$eType]}
					log_last=${AE_LOG[DIR_LAST]}${AE_LOG[DIR_$eType]}${AE_SUPD[${i}_LOG]}${AE_LOG[EXT_$eType]}
					# start last log
					dt_mark &> "$log_last"
					# choose update method and do update
					case "-${AE_SUPD[${i}_METHOD]}-" in
						-task-) # adding cmds to task file
								if (($AE_VCS)); then
									# array cmds
									#declare -a Cmds
									#mapfile -t Cmds <<< "${AE_SUPD[${i}_CMD]}"
									mapfile -t Cmds < <(echo -e "${AE_SUPD[${i}_CMD]}")
									einfo "        Adding ${#Cmds[*]} tasks to update the subset:"
									# to-do: aggregate all filenames at the top
									if [ -e "${AE_DIR[GATEWAY]}${AECMD[FILE_PREFIX]}${AE_TASK[FILE_LIST]}" ]; then
										mapfile -t Tasks < "${AE_DIR[GATEWAY]}${AECMD[FILE_PREFIX]}${AE_TASK[FILE_LIST]}"
									else
										declare Tasks
									fi
									addTasks=''
									l=0
									for ((k=0; k < ${#Cmds[*]}; k++)); do
										# search for scheduled task
										for ((l1=l; l1 < ${#Tasks[*]}; l1++)); do
											if [ "${Cmds[$k]}" == "${Tasks[$l1]}" ]; then
												l=$l1
												break
											fi
										done
										# found ?
										if ((l1 != ${#Tasks[*]})); then
											ewarn "          - skipped '${Cmds[$k]}': already scheduled"
										else
											l=$l1
											einfo "          - '${Cmds[$k]}'"
											[ "$addTasks" ] && addTasks+="\n"
											addTasks+="${Cmds[$k]}"
										fi
										# check for world rebuild
										# [[ "$k" == *"-e @world"* ]] && ((loopLogic|=0x1000))
									done
									[ "${addTasks}" = '' ] || ae_add_task "${addTasks}" &>> "$log_last" && \
										true && updated=2
									eend 0
									#unset Cmds
									# add user task pass
									loopLogic_set USER_TASKS
								else
									echo "Using tasks from VCS." >> "$log_last"
									einfo "        Using tasks from VCS."
									eend 0
								fi
								;;
						-1-pass-|-2-pass-) 
								# 2-pass logic:
								if [ "${AE_SUPD[${i}_METHOD]}" == "2-pass" ]; then
									# get opponent for 'two-pass' update
									if (($AE_VCS)); then
									 osf="${AE_DIR[GATEWAY]}.${AE_RCMD[INSTALL_FILE_PREFIX]}${AE_SIGN[SUBSET_UPDATES]}"
									else
										osf="${AE_DIR[GATEWAY]}.${AE_RCMD[COOK_FILE_PREFIX]}${AE_SIGN[SUBSET_UPDATES]}"
									fi
									if [ -e "$osf" ]; then
										gexp=''
										for sens in ${AE_SUPD[${i}_SENSOR]}; do gexp+=" -e $sens:"; done # multisensor
										ostest=$((`grep $gexp "$osf" | grep '2-pass' | wc -l`))
									else
										ostest=0
									fi
									if !(($ostest)); then
										ewarn "        This is the first pass of the update. " \
											"Skipping package switch and system depclean."; eend 0
										dcPend=1
										updated=1
									fi
								fi
								# update (1-pass/second pass) logic
								if !(($updated)); then
									# array cmds
									mapfile -t Cmds < <(echo -e "${AE_SUPD[${i}_CMD]}")
									# play cmds
									for ((k=0; k < ${#Cmds[*]}; k++)); do
										(($cmdRet)) && break
										cmd="${Cmds[$k]# ?}"
										((k1=$k+1))
										if [ "$cmd" ]; then
											# log $cmd
											echo "$cmd" &>> "$log_last"
											# choose caller
											if [[ "$cmd" == '#'* ]]; then # shell cmd
												cmd=${cmd:1}
												# --usepkg logic
												!(($AE_VCS)) && cmd=${cmd/--usepkg n/--usepkg y}
												#einfo "        Running shell command:"
												einfo "        - $k1/${#Cmds[*]}. '$cmd' ..."
												# mark last log
												dt_mark &>> "$log_last"
												if [ "$AE_MW_VERBOSE" ]; then
													eval "$cmd 2>&1 | tee -a \"$log_last\""
												else
													eval "$cmd &>> \"$log_last\""
												fi
												echo "Retcode $cmdRet" &>> "$log_last"
												cmdRet=$?
											else # PM
												if [[ "$cmd" == '$'* || "$cmd" == '`'* ]]; then
													cmd=$(eval echo -n $cmd)
												fi
												if [ "$cmd" ]; then
													#einfo "        Running PM:"
													call_cmd1_with_emerge_solver \
														"    - $k1/${#Cmds[*]}. ${AECMD[SUBSET_UPDATE]} '$cmd'" \
														"${AECMD[SUBSET_UPDATE]} $cmd" \
														"$log_last" # "$log"
													cmdRet=$?
												else
													einfo "        Not found any dependencies for this subset."
													cmdRet=0
												fi
											fi
											# get result
											if (($cmdRet)); then 
												eend 1;	updated=0
											else 
												eend 0; updated=2
											fi
											# only for real update
											# collect hints for libs consumers rebuild
											#scan_for_rdlibs "$log"
											scan_for_rdlibs "$log_last"
											# add depclean and revdep-rebuild pass
											loopLogic_set WORLD_DEPCLEAN
											loopLogic_set WORLD_REVDEP
										else
											echo "skip empty line in '${AE_SUPD[${i}_CMD]}'"
										fi
									done
								fi
								;;
						*) echo "Invalid update method: '${AE_SUPD[${s}_METHOD]}'!"
					esac
				
					# end last_logs
					cat "$log_last" &>> "$log"
					echo &>> "$log"

					# subset sign update
					if (($updated)); then
						# multisensor
						for sens in ${AE_SUPD[${i}_SENSOR]}; do 
							# save update sign (for 2-pass)
							sul=`grep "$sens:" "${AESIGN[SUBSET_UPDATES]}"`
							sul=${sul/*: /}; sul=${sul/2-pass, /}
							# remove subset sign
							nsupd=`grep -v "$sens:" "${AESIGN[SUBSET_UPDATES]}"`
							# remove empty
							if [ "$nsupd" ]; then
								echo "$nsupd" > "${AESIGN[SUBSET_UPDATES]}"
							else
								rm -v "${AESIGN[SUBSET_UPDATES]}" &> /dev/null
							fi
							if !(($updated-1)); then # re-add subset sign with '1-pass'
								echo "$sens: 2-pass, $sul" >> "${AESIGN[SUBSET_UPDATES]}"
							fi
						done
						# if update is done - remove sign of update
						if (($updated-1)); then
							unset AE_SUPD[${i}_UPDATED]
							unset AE_SUPD[${i}_CRITICAL_CHANGE]
							# do world update again (check)
							loopLogic_set WORLD_UPDATE
						fi
					else # pend depclean if collision occurred
						dcPend=1
						# failed - set the bit again!!!
						loopLogic_set SUBSET_UPDATE
					fi
				elif [ "${AE_SUPD[${i}_PENDED]}" ]; then
					[ "$pended" ] && pended+=', '
					pended+=${AE_SUPD[${i}_TITLE]}
					# set the bit again for pended subsets
					loopLogic_set SUBSET_UPDATE
				elif [ "${AE_SUPD[${i}_NOTINSTALLED]}" ]; then
					[ "$notinstalled" ] && notinstalled+=', '
					notinstalled+=${AE_SUPD[${i}_TITLE]}
				else
					[ "$undetected" ] && undetected+=', '
					undetected+=${AE_SUPD[${i}_TITLE]}
				fi
			done
			[ "$pended" ] && einfo "      $pended updates are pended till the next pass."; eend 0
			[ "$undetected" ] && einfo "      $undetected updates were not detected."; eend 0
			[ "$notinstalled" ] && einfo "      $notinstalled updates were skipped: not installed."; eend 0
		else
			einfo "    Subsets already have been updated."; eend 0
		fi
	else 
		ewarn "    Checking for various subsets updates is not configured."; eend 0
	fi
	loopLogicLog

	
	# Cleanup all unneded (DEPCLEAN), emerge -ca
	if [ "${AE_REBUILD[DO_DEPCLEAN]}" == "y" ]; then
		if (($loopLogic & ${AE_RBLL[WORLD_DEPCLEAN]})); then
			if [ $dcPend ]; then
				ewarn "    Cleaning system is delayed till the next pass. "\
					"(2-pass subset update behavior or subset update fail)"; eend 0
			elif [ $dcPend2 ]; then
				ewarn "    Cleaning system is delayed till the next pass. "\
					"(Critical system packages update behavior)"; eend 0
			else
				call_cmd1 "Cleaning system from unused dependencies" "${AECMD[DEPCLEAN]}" \
							"${AELOG[DEPCLEAN_LAST]}" "${AELOG[DEPCLEAN]}"
				# reset this if OK
				(($cmdRet)) || loopLogic_reset WORLD_DEPCLEAN
				# add revdep-rebuild pass
				loopLogic_set WORLD_REVDEP
			fi
		else
			if (($loopLogic & ${AE_RBLL[WORLD_UPDATE]})); then # check
				einfo "    Cleaning system is delayed till the next pass."\
					"(Uncompleted world update)"; eend 0
			else
				einfo "    System already has been cleaned."; eend 0
			fi
		fi
	else 
		# reset this
		loopLogic_reset WORLD_DEPCLEAN
		ewarn "    Cleaning system is not configured."; eend 0
	fi
	loopLogicLog

	
	# REVDEP CONSUMERS for advised libs, revdep --libs
	if [ "${AE_REBUILD[DO_OBSOLETED_LIBS]}" == "y" ]; then
		if (($loopLogic & ${AE_RBLL[OBSOLETED_LIBS_REVDEP]})); then
			# reset this
			loopLogic_reset OBSOLETED_LIBS_REVDEP
			# sign file
			f=${AE_DIR[REBUILD_VAR]}.${AECMD[FILE_PREFIX]}${AE_REBUILD[FILE_OBSOLETED_LIBS]}
			if [ -e "$f" ]; then
				cmd=${AECMD[OBSOLETED_LIBS]/\?/\\\($(sed -e :a -e '$!N; s,\n,\\\|,; s,<<< ,,g;  ta' < "$f")\\\)}
				#echo "obslibs cmd: $cmd"
				# call revdep
				call_cmd1 "Rebuilding for "$(wc -l < "$f")" advised libs consumers" "$cmd" \
						"${AELOG[OBSLLIBS_LAST]}" "${AELOG[OBSLLIBS]}"
				# copy libs list to logs
				echo " * Copy of advised libs list:" | tee -a "${AELOG[OBSLLIBS_LAST]}" >> "${AELOG[OBSLLIBS]}"
				tee -a "${AELOG[OBSLLIBS_LAST]}" >> "${AELOG[OBSLLIBS]}" < "$f"
				
				ol_ignore=''
				# check the result, skip unlinking if pended by NOT OK world update
				if ! (($cmdRet)) && ! [ "$dcPend2" ] && ! [ "$alcruPend" ]; then # OK
					# save list to avoid recursion
					ol_ignore=$(<"$f")
					einfo "      Unlinking advised obsoleted libs ..."
					# go throgh the list and unlink lost libs
					while read i; do 
						if [[ "$i" == "<<< "* ]]; then
							rm -v "${i:4}" 2>&1 | tee -a "${AELOG[OBSLLIBS_LAST]}" >> "${AELOG[OBSLLIBS]}"
						else
							echo "Skipping unlinking '$i' - not asked to remove it." | \
								tee -a "${AELOG[OBSLLIBS_LAST]}" >> "${AELOG[OBSLLIBS]}"
						fi
					done < "$f"
					eend 0
					true && rm -v "$f" 2>&1 | tee -a "${AELOG[OBSLLIBS_LAST]}" >> "${AELOG[OBSLLIBS]}"
				else # FAIL
					if [ "$dcPend2" ]; then
						ewarn "      Save lost libs list for further operations."\
								"(Critical system packages update behavior)"; eend 0
					elif [ "$alcruPend" ]; then
						ewarn "      Save lost libs list for further operations."\
								"(Uncompleted world update)"; eend 0
					else
						ewarn "      Save lost libs list for further operations."; eend 0
					fi
					# set this again
					loopLogic_set OBSOLETED_LIBS_REVDEP
				fi
				# collect hints for libs comsumers rebuild
				scan_for_rdlibs "${AELOG[OBSLLIBS_LAST]}" "$ol_ignore"
				# add revdep-rebuild pass
				loopLogic_set WORLD_REVDEP
			else
				einfo "    Not found any libs advised for consumers rebuilding."; eend 0
			fi
		else
			einfo "    Consumers for advised libs have been already rebuilt. "; eend 0
		fi
	else 
		# reset this
		loopLogic_reset OBSOLETED_LIBS_REVDEP
		ewarn "    Rebuilding of consumers for advised libs is not configured."; eend 0
	fi
	loopLogicLog

	
	# PRESERVED REBUILD
	if [ "${AE_REBUILD[DO_PRESERVED_REBUILD]}" == "y" ]; then
		if (($loopLogic & ${AE_RBLL[PRESERVED_REBUILD]})); then
			# 
			call_cmd1 "Rebuilding world with @preserved-rebuild" "${AECMD[PRESERVED_REBUILD]}" \
					"${AELOG[PRESERVED_LAST]}" "${AELOG[PRESERVED]}"
			# if OK - reset flag
			(($cmdRet)) || loopLogic_reset PRESERVED_REBUILD
			# collect hints for libs comsumers rebuild
			scan_for_rdlibs "${AELOG[PRESERVED_LAST]}"
		else
			einfo "    Rebuilding world with @preserved-rebuild has been already done."; eend 0
		fi
	else 
		# reset revdep flag
		loopLogic_reset PRESERVED_REBUILD
		ewarn "    Rebuilding world with @preserved-rebuild is not configured."; eend 0
	fi
	loopLogicLog


	# REVDEP system-wide
	if [ "${AE_REBUILD[DO_REVDEP_REBUILD]}" == "y" ]; then
		if (($loopLogic & ${AE_RBLL[WORLD_REVDEP]})); then
			# call global revdep
			# checking: call_cmd0
			call_cmd1 "Rebuilding world with revdep-rebuild" "${AECMD[REVDEP_REBUILD]}" \
					"${AELOG[REVDEP_LAST]}" "${AELOG[REVDEP]}"
			# if OK - reset revdep flag
			(($cmdRet)) || loopLogic_reset WORLD_REVDEP
			# collect hints for libs comsumers rebuild
			scan_for_rdlibs "${AELOG[REVDEP_LAST]}"
		else
			einfo "    Rebuilding world with revdep-rebuild has been already done."; eend 0
		fi
	else 
		# reset revdep flag
		loopLogic_reset WORLD_REVDEP
		ewarn "    Rebuilding world with revdep-rebuild is not configured."; eend 0
	fi
	loopLogicLog


	# Proceed TASKS with cmd/emerge
	if [ "${AE_REBUILD[DO_USER_TASKS]}" == "y" ]; then
		if (($loopLogic & ${AE_RBLL[USER_TASKS]})); then
			# reset this
			loopLogic_reset USER_TASKS
			f="${AE_DIR[GATEWAY]}${AECMD[FILE_PREFIX]}${AE_TASK[FILE_LIST]}"
			if [ -e "$f" ]; then 
				totalTasks=$(wc -l < "$f")
				countTasks=1
				einfo "    Running $totalTasks scheduled tasks:" # + loop+1
				# walk through to-do
				cmdRet=0
				while [[ -e "$f" && $cmdRet == 0 ]]; do
					i=$(head -n1 "$f")
					i=${i# ?} # strip leading spaces
					if [ "$i" ]; then
						# start last log
						dt_mark &> "${AELOG[TASKS_LAST]}"
						# save origin line
						is="$i"
						# choose caller
						if [[ "$i" == '#'* ]]; then # shell cmd
							i=${i:1}
							# --usepkg logic: replace /--usepkg n/--usepkg y/ if given
							!(($AE_VCS)) && i=${i/--usepkg n/--usepkg y}
							#einfo "      Running shell command: '$i' ..."
							einfo "      - $countTasks/$totalTasks. '$i' ..."
#							eval "$i &>> \"${AELOG[TASKS_LAST]}\""
							if [ "$AE_MW_VERBOSE" ]; then
								eval "$i 2>&1 | tee -a \"${AELOG[TASKS_LAST]}\""
							else
								eval "$i &>> \"${AELOG[TASKS_LAST]}\""
							fi
							cmdRet=$?
							echo "Retcode $cmdRet" &>> "${AELOG[TASKS_LAST]}"
						else # PM
							#einfo "      Running PM: '${AECMD[USER_TASKS]} $i' ..."
							einfo "      - $countTasks/$totalTasks. ${AECMD[USER_TASKS]} '$i' ..."
							# eval params if started with $ or ` (shell cmd) 
							if [[ "$i" == '$'* || "$i" == '`'* ]]; then
								i=$(eval echo -n $i)
							fi
							# check params for empty
							if [ "$i" ]; then
#								eval "${AECMD[USER_TASKS]} $i &>> \"${AELOG[TASKS_LAST]}\""
								if [ "$AE_MW_VERBOSE" ]; then
									eval "${AECMD[USER_TASKS]} $i 2>&1 | tee -a \"${AELOG[TASKS_LAST]}\""
								else
									eval "${AECMD[USER_TASKS]} $i &>> \"${AELOG[TASKS_LAST]}\""
								fi
								cmdRet=$?
							else
								einfo "        Not found any params for this task."
								cmdRet=0
							fi
							echo "Retcode $cmdRet" &>> "${AELOG[TASKS_LAST]}" 
						fi
						eend $cmdRet
						# copy last to logs
						cat "${AELOG[TASKS_LAST]}" &>> "${AELOG[TASKS]}"
						echo &>> "${AELOG[TASKS]}"
						# add cmd to install to-do; skip duplicates. only if success 
						# to-do: update it as above ???
						if ((! $cmdRet && $AE_VCS)); then
							egrep "^${is}$" \
								"${AE_DIR[GATEWAY]}${AE_RCMD[INSTALL_FILE_PREFIX]}${AE_TASK[FILE_LIST]}" &> /dev/null
							(($?)) && echo "$is" >> \
								"${AE_DIR[GATEWAY]}${AE_RCMD[INSTALL_FILE_PREFIX]}${AE_TASK[FILE_LIST]}"
						fi
					else
						echo "skip empty line in '$f'"
					fi
					# remove 1st line from to-do. only if success 
					if !(($cmdRet)); then
						c=$(tail -n+2 "$f")
						if [ "$c" ]; then
							echo -e "$c" > "$f"
						else
							rm -f "$f"
						fi
					fi
					((countTasks++))
				done

				# if failed - set the flag again
				(($cmdRet)) && loopLogic_set USER_TASKS

				# add depclean and revdep-rebuild pass
				# and world update
				loopLogic_set WORLD_UPDATE
				loopLogic_set WORLD_DEPCLEAN
				loopLogic_set WORLD_REVDEP

				# check for rebuild advised libs
				scan_for_rdlibs "${AELOG[TASKS_LAST]}"
			else
				einfo "    There are no scheduled tasks."; eend 0
			fi
		else
			einfo "    All scheduled tasks have been already done."; eend 0
		fi
	else 
		# reset this
		loopLogic_reset USER_TASKS
		ewarn "    Running scheduled tasks is not configured."; eend 0
	fi
	loopLogicLog
done


# Bye World
if (($loopLogic)); then
	eerror "  Can't recover system consistency! Will try again next time."; eend 1
else
	einfo "  Now the system is consistently."; eend 0
fi


# DO GRS CLEAN-UPs & ETC-UPDATE
# to-do: add logging!!!
if !(($AE_VCS)); then
	# Clean-up VCS if not building
	if [ "${AE_INSTALL[DO_VCS_CLEANUP]}" == "y" ]; then
		# to-do: better locking
		if [ -e "${AE_PID[AE_REBUILD_PATH]}${AE_RCMD[COOK_FILE_PREFIX]}${AE_PID[AE_REBUILD_FILE]}" ]; then 
			ewarn "  Cooking binary packages is in progress: skipping VCS cleanup!"; eend 1
		else
			einfo "  Cleaning VCS:"
			ae_delta_cleanup && ae_chroot_cleanup
		fi
	else
		einfo "  VCS cleanup is not configured."
		eend 0
	fi


	# eclean-dist
	if [ "${AE_INSTALL[DO_ECLEAN_DIST]}" == "y" ]; then
		einfo "  Unlinking obsoleted distfiles:"
		${AE_CMD[ECLEAN_DIST]}
	else
		einfo "  Unlinking obsoleted distfiles is not configured."
		eend 0
	fi


	# eclean-pkg
	if [ "${AE_INSTALL[DO_ECLEAN_PKG]}" == "y" ]; then
		einfo "  Unlinking obsoleted binary packages:"
		${AE_CMD[ECLEAN_PKG]}
	else
		einfo "  Unlinking obsoleted binary packages is not configured."
		eend 0
	fi


	# etc-update
	if [ "${AE_INSTALL[DO_ETC_UPDATE]}" == "y" ]; then
		einfo "  Updating configs (interactively):"
		${AE_CMD[ETC_UPDATE]}
	else
		einfo "  Config update is not configured."
		eend 0
	fi

	# to-do: print out install.emerge.warn.log

	einfo "Binary packages installation is finished!"
	eend 0
fi

#times

#return $cmdRet
exit $loopLogic


